{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/web3-3/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/web3-3/client/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nvar assert = require('assert');\n\nvar BN = require(\"bn.js\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar account_1 = require(\"./account\");\n\nvar Address = /*#__PURE__*/function () {\n  function Address(buf) {\n    _classCallCheck(this, Address);\n\n    assert(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  _createClass(Address, [{\n    key: \"equals\",\n    value:\n    /**\n     * Is address equal to another.\n     */\n    function equals(address) {\n      return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.equals(Address.zero());\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return Buffer.from(this.buf);\n    }\n  }], [{\n    key: \"zero\",\n    value: function zero() {\n      return new Address(bytes_1.zeros(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      assert(account_1.isValidAddress(str), 'Invalid address');\n      return new Address(bytes_1.toBuffer(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n\n  }, {\n    key: \"fromPublicKey\",\n    value: function fromPublicKey(pubKey) {\n      assert(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n      var buf = account_1.pubToAddress(pubKey);\n      return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      assert(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n      var buf = account_1.privateToAddress(privateKey);\n      return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n\n  }, {\n    key: \"generate\",\n    value: function generate(from, nonce) {\n      assert(BN.isBN(nonce));\n      return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n\n  }, {\n    key: \"generate2\",\n    value: function generate2(from, salt, initCode) {\n      assert(Buffer.isBuffer(salt));\n      assert(Buffer.isBuffer(initCode));\n      return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n    }\n  }]);\n\n  return Address;\n}();\n\nexports.Address = Address;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAM,MAAM,GAAG,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAA,EAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;IAQa,O;AAGX,mBAAY,GAAZ,EAAuB;AAAA;;AACrB,IAAA,MAAM,CAAC,GAAG,CAAC,MAAJ,KAAe,EAAhB,EAAoB,wBAApB,CAAN;AACA,SAAK,GAAL,GAAW,GAAX;AACD;AAED;;AAEG;;;;;;AAwDH;;AAEG;AACH,oBAAO,OAAP,EAAuB;AACrB,aAAO,KAAK,GAAL,CAAS,MAAT,CAAgB,OAAO,CAAC,GAAxB,CAAP;AACD;AAED;;AAEG;;;;WACH,kBAAM;AACJ,aAAO,KAAK,MAAL,CAAY,OAAO,CAAC,IAAR,EAAZ,CAAP;AACD;AAED;;AAEG;;;;WACH,oBAAQ;AACN,aAAO,OAAO,KAAK,GAAL,CAAS,QAAT,CAAkB,KAAlB,CAAd;AACD;AAED;;AAEG;;;;WACH,oBAAQ;AACN,aAAO,MAAM,CAAC,IAAP,CAAY,KAAK,GAAjB,CAAP;AACD;;;WAjFD,gBAAW;AACT,aAAO,IAAI,OAAJ,CAAY,OAAA,CAAA,KAAA,CAAM,EAAN,CAAZ,CAAP;AACD;AAED;;;AAGG;;;;WACH,oBAAkB,GAAlB,EAA6B;AAC3B,MAAA,MAAM,CAAC,SAAA,CAAA,cAAA,CAAe,GAAf,CAAD,EAAsB,iBAAtB,CAAN;AACA,aAAO,IAAI,OAAJ,CAAY,OAAA,CAAA,QAAA,CAAS,GAAT,CAAZ,CAAP;AACD;AAED;;;AAGG;;;;WACH,uBAAqB,MAArB,EAAmC;AACjC,MAAA,MAAM,CAAC,MAAM,CAAC,QAAP,CAAgB,MAAhB,CAAD,EAA0B,6BAA1B,CAAN;AACA,UAAM,GAAG,GAAG,SAAA,CAAA,YAAA,CAAa,MAAb,CAAZ;AACA,aAAO,IAAI,OAAJ,CAAY,GAAZ,CAAP;AACD;AAED;;;AAGG;;;;WACH,wBAAsB,UAAtB,EAAwC;AACtC,MAAA,MAAM,CAAC,MAAM,CAAC,QAAP,CAAgB,UAAhB,CAAD,EAA8B,8BAA9B,CAAN;AACA,UAAM,GAAG,GAAG,SAAA,CAAA,gBAAA,CAAiB,UAAjB,CAAZ;AACA,aAAO,IAAI,OAAJ,CAAY,GAAZ,CAAP;AACD;AAED;;;;AAIG;;;;WACH,kBAAgB,IAAhB,EAA+B,KAA/B,EAAwC;AACtC,MAAA,MAAM,CAAC,EAAE,CAAC,IAAH,CAAQ,KAAR,CAAD,CAAN;AACA,aAAO,IAAI,OAAJ,CAAY,SAAA,CAAA,eAAA,CAAgB,IAAI,CAAC,GAArB,EAA0B,KAAK,CAAC,WAAN,CAAkB,MAAlB,CAA1B,CAAZ,CAAP;AACD;AAED;;;;;AAKG;;;;WACH,mBAAiB,IAAjB,EAAgC,IAAhC,EAA8C,QAA9C,EAA8D;AAC5D,MAAA,MAAM,CAAC,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAD,CAAN;AACA,MAAA,MAAM,CAAC,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAAD,CAAN;AACA,aAAO,IAAI,OAAJ,CAAY,SAAA,CAAA,gBAAA,CAAiB,IAAI,CAAC,GAAtB,EAA2B,IAA3B,EAAiC,QAAjC,CAAZ,CAAP;AACD;;;;;;AAhEH,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst assert = require('assert');\nconst BN = require(\"bn.js\");\nconst bytes_1 = require(\"./bytes\");\nconst account_1 = require(\"./account\");\nclass Address {\n    constructor(buf) {\n        assert(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address(bytes_1.zeros(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        assert(account_1.isValidAddress(str), 'Invalid address');\n        return new Address(bytes_1.toBuffer(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        assert(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        const buf = account_1.pubToAddress(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        assert(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        const buf = account_1.privateToAddress(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        assert(BN.isBN(nonce));\n        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        assert(Buffer.isBuffer(salt));\n        assert(Buffer.isBuffer(initCode));\n        return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}