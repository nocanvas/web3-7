{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nvar web3_1 = __importDefault(require(\"web3\"));\n\nvar events_1 = require(\"events\");\n\nvar timeout_1 = __importDefault(require(\"../util/timeout\"));\n\nvar gsn_provider_1 = require(\"@openzeppelin/gsn-provider\");\n\nvar network_1 = __importDefault(require(\"../util/network\"));\n\nvar providerName_1 = __importDefault(require(\"../util/providerName\")); // TODO: Change event to use types using conditional types\n\n\nvar Web3Context = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Web3Context, _events_1$EventEmitte);\n\n  var _super = _createSuper(Web3Context);\n\n  function Web3Context(provider, options) {\n    var _this;\n\n    _classCallCheck(this, Web3Context);\n\n    _this = _super.call(this);\n    _this.connected = false;\n    _this.accounts = [];\n    _this.networkId = null;\n    _this.networkName = null;\n    var fullOptions = Object.assign({}, {\n      timeout: 3000,\n      pollInterval: 500,\n      gsn: false\n    }, options);\n    if (!provider) throw new Error('A web3 provider has to be defined');\n\n    if (fullOptions.gsn) {\n      var gsnOptions = typeof fullOptions.gsn === 'object' ? fullOptions.gsn : {\n        useGSN: true\n      };\n      provider = !gsnOptions.dev ? new gsn_provider_1.GSNProvider(provider, gsnOptions) : new gsn_provider_1.GSNDevProvider(provider, gsnOptions);\n    }\n\n    _this.providerName = providerName_1.default(provider);\n    _this.lib = new web3_1.default(provider);\n    _this.timeout = fullOptions.timeout;\n    _this.pollInterval = fullOptions.pollInterval;\n    return _this;\n  }\n\n  _createClass(Web3Context, [{\n    key: \"startPoll\",\n    value: function startPoll() {\n      if (!this.pollHandle) {\n        // TODO: polling interval should depend on kind of web3 provider\n        // We can query local providers often but doing the same for the network providers may create a lot of overhead\n        this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n      }\n    }\n  }, {\n    key: \"stopPoll\",\n    value: function stopPoll() {\n      if (this.pollHandle) {\n        clearTimeout(this.pollHandle);\n        this.pollHandle = undefined;\n      }\n    }\n  }, {\n    key: \"poll\",\n    value: function () {\n      var _poll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var networkIdName, accountsName, connectedName, networkNameName, newNetworkId, newNetworkName, newAccounts;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // TODO: Fiture out elegant way retrive property name dynamically\n                networkIdName = 'networkId';\n                accountsName = 'accounts';\n                connectedName = 'connected'; // getting deep here\n\n                networkNameName = 'networkName';\n                _context.prev = 4;\n                _context.next = 7;\n                return timeout_1.default(this.lib.eth.net.getId(), this.timeout);\n\n              case 7:\n                newNetworkId = _context.sent;\n                newNetworkName = network_1.default(newNetworkId);\n                this.updateValueAndFireEvent(newNetworkName, networkNameName);\n                this.updateValueAndFireEvent(newNetworkId, networkIdName, Web3Context.NetworkIdChangedEventName, function () {\n                  return [newNetworkName];\n                }); // get the accounts\n\n                _context.next = 13;\n                return timeout_1.default(this.lib.eth.getAccounts(), this.timeout);\n\n              case 13:\n                newAccounts = _context.sent;\n                this.updateValueAndFireEvent(newAccounts, accountsName, Web3Context.AccountsChangedEventName); // if web3 provider calls are success then we are connected\n\n                this.updateValueAndFireEvent(true, connectedName, Web3Context.ConnectionChangedEventName);\n                _context.next = 24;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](4);\n                // provider methods fail so we have to update the state and fire the events\n                this.updateValueAndFireEvent(false, connectedName, Web3Context.ConnectionChangedEventName);\n                this.updateValueAndFireEvent(null, networkIdName, Web3Context.NetworkIdChangedEventName, function () {\n                  return [null];\n                });\n                this.updateValueAndFireEvent(null, networkNameName);\n                this.updateValueAndFireEvent(null, accountsName, Web3Context.AccountsChangedEventName); // TODO: Implement throtling so we do not spam console\n                // console.log(e);\n\n              case 24:\n                _context.prev = 24;\n                this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n                return _context.finish(24);\n\n              case 27:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 18, 24, 27]]);\n      }));\n\n      function poll() {\n        return _poll.apply(this, arguments);\n      }\n\n      return poll;\n    }()\n  }, {\n    key: \"updateValueAndFireEvent\",\n    value: function updateValueAndFireEvent(newValue, property, eventName) {\n      var getArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {\n        return [];\n      };\n\n      if (!fast_deep_equal_1.default(newValue, this[property])) {\n        this[property] = newValue;\n        if (eventName) this.emit.apply(this, [eventName, this[property]].concat(_toConsumableArray(getArgs())));\n      }\n    } // request access according to the EIP\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n\n  }, {\n    key: \"requestAuth\",\n    value: function () {\n      var _requestAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.lib.currentProvider.send !== undefined)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var responseHandler = function responseHandler(error, response) {\n                    if (error || response.error) {\n                      reject(error || response.error);\n                    } else {\n                      resolve(response.result);\n                    }\n                  };\n\n                  var send = _this2.lib.currentProvider.send;\n                  send({\n                    method: 'eth_requestAccounts'\n                  }, responseHandler);\n                }));\n\n              case 4:\n                return _context2.abrupt(\"return\", Promise.reject(new Error(\"Web3 provider doesn't support send method\")));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function requestAuth() {\n        return _requestAuth.apply(this, arguments);\n      }\n\n      return requestAuth;\n    }()\n  }]);\n\n  return Web3Context;\n}(events_1.EventEmitter);\n\nWeb3Context.NetworkIdChangedEventName = 'NetworkIdChanged';\nWeb3Context.AccountsChangedEventName = 'AccountsChanged';\nWeb3Context.ConnectionChangedEventName = 'ConnectionChanged';\nexports.default = Web3Context;","map":{"version":3,"sources":["../../src/context/Web3Context.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,iBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAGA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,IAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,sBAAA,CAAA,CAAA,C,CAiBA;;;IACqB,W;;;;;AAiBnB,uBAAmB,QAAnB,EAAuC,OAAvC,EAA4E;AAAA;;AAAA;;AAC1E;AARK,UAAA,SAAA,GAAqB,KAArB;AACA,UAAA,QAAA,GAA4B,EAA5B;AACA,UAAA,SAAA,GAA2B,IAA3B;AACA,UAAA,WAAA,GAA6B,IAA7B;AAOL,QAAM,WAAW,GAAuB,MAAM,CAAC,MAAP,CACtC,EADsC,EAEtC;AAAE,MAAA,OAAO,EAAE,IAAX;AAAiB,MAAA,YAAY,EAAE,GAA/B;AAAoC,MAAA,GAAG,EAAE;AAAzC,KAFsC,EAGtC,OAHsC,CAAxC;AAMA,QAAI,CAAC,QAAL,EAAe,MAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;;AAEf,QAAI,WAAW,CAAC,GAAhB,EAAqB;AACnB,UAAM,UAAU,GAAwB,OAAO,WAAW,CAAC,GAAnB,KAA2B,QAA3B,GAAsC,WAAW,CAAC,GAAlD,GAAwD;AAAE,QAAA,MAAM,EAAE;AAAV,OAAhG;AACA,MAAA,QAAQ,GAAG,CAAC,UAAU,CAAC,GAAZ,GAAkB,IAAI,cAAA,CAAA,WAAJ,CAAgB,QAAhB,EAA0B,UAA1B,CAAlB,GAA0D,IAAI,cAAA,CAAA,cAAJ,CAAmB,QAAnB,EAA6B,UAA7B,CAArE;AACD;;AAED,UAAK,YAAL,GAAoB,cAAA,CAAA,OAAA,CAAgB,QAAhB,CAApB;AACA,UAAK,GAAL,GAAW,IAAI,MAAA,CAAA,OAAJ,CAAS,QAAT,CAAX;AACA,UAAK,OAAL,GAAe,WAAW,CAAC,OAA3B;AACA,UAAK,YAAL,GAAoB,WAAW,CAAC,YAAhC;AAnB0E;AAoB3E;;;;WAEM,qBAAS;AACd,UAAI,CAAC,KAAK,UAAV,EAAsB;AACpB;AACA;AACA,aAAK,UAAL,GAAkB,UAAU,CAAC,KAAK,IAAL,CAAU,IAAV,CAAe,IAAf,CAAD,EAAuB,KAAK,YAA5B,CAA5B;AACD;AACF;;;WAEM,oBAAQ;AACb,UAAI,KAAK,UAAT,EAAqB;AACnB,QAAA,YAAY,CAAC,KAAK,UAAN,CAAZ;AACA,aAAK,UAAL,GAAkB,SAAlB;AACD;AACF;;;;2EAEM;AAAA;AAAA;AAAA;AAAA;AAAA;AACL;AACM,gBAAA,aAFD,GAEiB,WAFjB;AAGC,gBAAA,YAHD,GAGgB,UAHhB;AAIC,gBAAA,aAJD,GAIiB,WAJjB,EAKL;;AACM,gBAAA,eAND,GAMmB,aANnB;AAAA;AAAA;AAAA,uBASwB,SAAA,CAAA,OAAA,CAAQ,KAAK,GAAL,CAAS,GAAT,CAAa,GAAb,CAAiB,KAAjB,EAAR,EAAkC,KAAK,OAAvC,CATxB;;AAAA;AASG,gBAAA,YATH;AAWG,gBAAA,cAXH,GAWoB,SAAA,CAAA,OAAA,CAAe,YAAf,CAXpB;AAYH,qBAAK,uBAAL,CAA6B,cAA7B,EAA6C,eAA7C;AACA,qBAAK,uBAAL,CACE,YADF,EAEE,aAFF,EAGE,WAAW,CAAC,yBAHd,EAIE;AAAA,yBAAiB,CAAC,cAAD,CAAjB;AAAA,iBAJF,EAbG,CAmBH;;AAnBG;AAAA,uBAoBuB,SAAA,CAAA,OAAA,CAAQ,KAAK,GAAL,CAAS,GAAT,CAAa,WAAb,EAAR,EAAoC,KAAK,OAAzC,CApBvB;;AAAA;AAoBG,gBAAA,WApBH;AAqBH,qBAAK,uBAAL,CAA6B,WAA7B,EAA0C,YAA1C,EAAwD,WAAW,CAAC,wBAApE,EArBG,CAsBH;;AACA,qBAAK,uBAAL,CAA6B,IAA7B,EAAmC,aAAnC,EAAkD,WAAW,CAAC,0BAA9D;AAvBG;AAAA;;AAAA;AAAA;AAAA;AAyBH;AACA,qBAAK,uBAAL,CAA6B,KAA7B,EAAoC,aAApC,EAAmD,WAAW,CAAC,0BAA/D;AACA,qBAAK,uBAAL,CAA6B,IAA7B,EAAmC,aAAnC,EAAkD,WAAW,CAAC,yBAA9D,EAAyF;AAAA,yBAAiB,CAAC,IAAD,CAAjB;AAAA,iBAAzF;AACA,qBAAK,uBAAL,CAA6B,IAA7B,EAAmC,eAAnC;AACA,qBAAK,uBAAL,CAA6B,IAA7B,EAAmC,YAAnC,EAAiD,WAAW,CAAC,wBAA7D,EA7BG,CA8BH;AACA;;AA/BG;AAAA;AAiCH,qBAAK,UAAL,GAAkB,UAAU,CAAC,KAAK,IAAL,CAAU,IAAV,CAAe,IAAf,CAAD,EAAuB,KAAK,YAA5B,CAA5B;AAjCG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAqCC,iCACN,QADM,EAEN,QAFM,EAGN,SAHM,EAIiC;AAAA,UAAvC,OAAuC,uEAAnB;AAAA,eAAiB,EAAjB;AAAA,OAAmB;;AAEvC,UAAI,CAAC,iBAAA,CAAA,OAAA,CAAM,QAAN,EAAgB,KAAK,QAAL,CAAhB,CAAL,EAAsC;AACpC,aAAK,QAAL,IAAiB,QAAjB;AACA,YAAI,SAAJ,EAAe,KAAK,IAAL,cAAU,SAAV,EAAqB,KAAK,QAAL,CAArB,4BAAwC,OAAO,EAA/C;AAChB;AACF,K,CAED;AACA;;;;;kFACO;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,sBAED,KAAK,GAAL,CAAS,eAAT,CAAyB,IAAzB,KAAkC,SAFjC;AAAA;AAAA;AAAA;;AAAA,kDAGI,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAA0B;AAC3C,sBAAM,eAAe,GAAG,SAAlB,eAAkB,CAAC,KAAD,EAAiB,QAAjB,EAAwE;AAC9F,wBAAI,KAAK,IAAI,QAAQ,CAAC,KAAtB,EAA6B;AAC3B,sBAAA,MAAM,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAnB,CAAN;AACD,qBAFD,MAEO;AACL,sBAAA,OAAO,CAAC,QAAQ,CAAC,MAAV,CAAP;AACD;AACF,mBAND;;AAOA,sBAAM,IAAI,GAAG,MAAI,CAAC,GAAL,CAAS,eAAT,CAAyB,IAAtC;AACA,kBAAA,IAAI,CAAC;AAAE,oBAAA,MAAM,EAAE;AAAV,mBAAD,EAAoC,eAApC,CAAJ;AACD,iBAVM,CAHJ;;AAAA;AAAA,kDAcS,OAAO,CAAC,MAAR,CAAe,IAAI,KAAJ,CAAU,2CAAV,CAAf,CAdT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EAzGgC,QAAA,CAAA,Y;;AACzB,WAAA,CAAA,yBAAA,GAA4B,kBAA5B;AACA,WAAA,CAAA,wBAAA,GAA2B,iBAA3B;AACA,WAAA,CAAA,0BAAA,GAA6B,mBAA7B;AAHhB,OAAA,CAAA,OAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst web3_1 = __importDefault(require(\"web3\"));\nconst events_1 = require(\"events\");\nconst timeout_1 = __importDefault(require(\"../util/timeout\"));\nconst gsn_provider_1 = require(\"@openzeppelin/gsn-provider\");\nconst network_1 = __importDefault(require(\"../util/network\"));\nconst providerName_1 = __importDefault(require(\"../util/providerName\"));\n// TODO: Change event to use types using conditional types\nclass Web3Context extends events_1.EventEmitter {\n    constructor(provider, options) {\n        super();\n        this.connected = false;\n        this.accounts = [];\n        this.networkId = null;\n        this.networkName = null;\n        const fullOptions = Object.assign({}, { timeout: 3000, pollInterval: 500, gsn: false }, options);\n        if (!provider)\n            throw new Error('A web3 provider has to be defined');\n        if (fullOptions.gsn) {\n            const gsnOptions = typeof fullOptions.gsn === 'object' ? fullOptions.gsn : { useGSN: true };\n            provider = !gsnOptions.dev ? new gsn_provider_1.GSNProvider(provider, gsnOptions) : new gsn_provider_1.GSNDevProvider(provider, gsnOptions);\n        }\n        this.providerName = providerName_1.default(provider);\n        this.lib = new web3_1.default(provider);\n        this.timeout = fullOptions.timeout;\n        this.pollInterval = fullOptions.pollInterval;\n    }\n    startPoll() {\n        if (!this.pollHandle) {\n            // TODO: polling interval should depend on kind of web3 provider\n            // We can query local providers often but doing the same for the network providers may create a lot of overhead\n            this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n        }\n    }\n    stopPoll() {\n        if (this.pollHandle) {\n            clearTimeout(this.pollHandle);\n            this.pollHandle = undefined;\n        }\n    }\n    async poll() {\n        // TODO: Fiture out elegant way retrive property name dynamically\n        const networkIdName = 'networkId';\n        const accountsName = 'accounts';\n        const connectedName = 'connected';\n        // getting deep here\n        const networkNameName = 'networkName';\n        try {\n            // get the current network ID\n            const newNetworkId = await timeout_1.default(this.lib.eth.net.getId(), this.timeout);\n            const newNetworkName = network_1.default(newNetworkId);\n            this.updateValueAndFireEvent(newNetworkName, networkNameName);\n            this.updateValueAndFireEvent(newNetworkId, networkIdName, Web3Context.NetworkIdChangedEventName, () => [newNetworkName]);\n            // get the accounts\n            const newAccounts = await timeout_1.default(this.lib.eth.getAccounts(), this.timeout);\n            this.updateValueAndFireEvent(newAccounts, accountsName, Web3Context.AccountsChangedEventName);\n            // if web3 provider calls are success then we are connected\n            this.updateValueAndFireEvent(true, connectedName, Web3Context.ConnectionChangedEventName);\n        }\n        catch (e) {\n            // provider methods fail so we have to update the state and fire the events\n            this.updateValueAndFireEvent(false, connectedName, Web3Context.ConnectionChangedEventName);\n            this.updateValueAndFireEvent(null, networkIdName, Web3Context.NetworkIdChangedEventName, () => [null]);\n            this.updateValueAndFireEvent(null, networkNameName);\n            this.updateValueAndFireEvent(null, accountsName, Web3Context.AccountsChangedEventName);\n            // TODO: Implement throtling so we do not spam console\n            // console.log(e);\n        }\n        finally {\n            this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n        }\n    }\n    updateValueAndFireEvent(newValue, property, eventName, getArgs = () => []) {\n        if (!fast_deep_equal_1.default(newValue, this[property])) {\n            this[property] = newValue;\n            if (eventName)\n                this.emit(eventName, this[property], ...getArgs());\n        }\n    }\n    // request access according to the EIP\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    async requestAuth() {\n        // Request authentication\n        if (this.lib.currentProvider.send !== undefined) {\n            return new Promise((resolve, reject) => {\n                const responseHandler = (error, response) => {\n                    if (error || response.error) {\n                        reject(error || response.error);\n                    }\n                    else {\n                        resolve(response.result);\n                    }\n                };\n                const send = this.lib.currentProvider.send;\n                send({ method: 'eth_requestAccounts' }, responseHandler);\n            });\n        }\n        else\n            return Promise.reject(new Error(\"Web3 provider doesn't support send method\"));\n    }\n}\nWeb3Context.NetworkIdChangedEventName = 'NetworkIdChanged';\nWeb3Context.AccountsChangedEventName = 'AccountsChanged';\nWeb3Context.ConnectionChangedEventName = 'ConnectionChanged';\nexports.default = Web3Context;\n//# sourceMappingURL=Web3Context.js.map"]},"metadata":{},"sourceType":"script"}