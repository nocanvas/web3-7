{"ast":null,"code":"const BN = require('web3').utils.toBN;\n\nconst abi = require('web3-eth-abi'); //relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\n\n\nconst DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nclass ActiveRelayPinger {\n  // TODO: 'httpSend' should be on a network layer\n  constructor(filteredRelays, httpSend, gasPrice, verbose) {\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n    this.errors = [];\n  }\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  async nextRelay() {\n    if (this.remainingRelays.length === 0) {\n      return null;\n    }\n\n    let firstRelayToRespond;\n\n    for (; !firstRelayToRespond && this.remainingRelays.length;) {\n      let bulkSize = Math.min(3, this.remainingRelays.length);\n\n      try {\n        let slice = this.remainingRelays.slice(0, bulkSize);\n\n        if (this.verbose) {\n          console.log('nextRelay: find fastest relay from: ' + JSON.stringify(slice));\n        }\n\n        firstRelayToRespond = await this.raceToSuccess(slice.map(relay => this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, this.gasPrice)));\n\n        if (this.verbose) {\n          console.log('race finished with a champion: ' + firstRelayToRespond.relayUrl);\n        }\n      } catch (e) {\n        if (this.verbose) {\n          console.log('One batch of relays failed, last error: ', e);\n        } //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n\n\n        this.remainingRelays = this.remainingRelays.slice(bulkSize);\n      }\n    }\n\n    this.remainingRelays = this.remainingRelays.filter(a => a.relayUrl !== firstRelayToRespond.relayUrl);\n    this.pingedRelays++;\n    return firstRelayToRespond;\n  }\n  /**\n   * @returns JSON response from the relay server, but adds the requested URL to it:\n   * { relayUrl: url,\n   *   transactionFee: fee,\n   *   RelayServerAddress: address,\n   *   Ready: bool,   //should ignore relays with \"false\"\n   *   MinGasPrice:   //minimum gas requirement by this relay.\n   * }\n   */\n\n\n  async getRelayAddressPing(relayUrl, transactionFee, gasPrice) {\n    let self = this;\n    return new Promise(function (resolve, reject) {\n      let callback = function (error, body) {\n        if (error) {\n          reject(`Error querying relayer ${relayUrl}: ${error.message || error.error || error.toString()}`);\n          return;\n        }\n\n        if (!body) {\n          reject(`Empty response from relayer ${relayUrl}`);\n          return;\n        }\n\n        if (!body.Ready) {\n          reject(`Relayer ${relayUrl} is not ready`);\n          return;\n        }\n\n        if (body.MinGasPrice > gasPrice) {\n          reject(`Relayer ${relayUrl} requires a minimum gas price of ${body.MinGasPrice} which is over this transaction gas price (${gasPrice})`);\n          return;\n        }\n\n        try {\n          //add extra attributes (relayUrl, transactionFee)\n          Object.assign(body, {\n            relayUrl,\n            transactionFee\n          });\n          resolve(body);\n        } catch (err) {\n          reject(err);\n        }\n      };\n\n      if (self.verbose) {\n        console.log('getRelayAddressPing URL: ' + relayUrl);\n      }\n\n      self.httpSend.send(relayUrl + '/getaddr', {}, callback);\n    });\n  }\n  /**\n   * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n   * Resolves once any promise resolves, ignores the rest, ignores rejections\n   */\n\n\n  async raceToSuccess(promises) {\n    let numRejected = 0;\n    return new Promise((resolve, reject) => promises.forEach(promise => promise.then(res => {\n      resolve(res);\n    }).catch(err => {\n      this.errors.push(err);\n\n      if (++numRejected === promises.length) {\n        reject('No response matched filter from any server: ' + err);\n      }\n    })));\n  }\n\n}\n\nclass ServerHelper {\n  constructor(httpSend, failedRelays, {\n    verbose,\n    minStake,\n    minDelay,\n    //params for relayFilter: filter out this relay if unstakeDelay or stake are too low.\n    relayTimeoutGrace,\n    //ignore score drop of a relay after this time (seconds)\n    calculateRelayScore,\n    //function: return relay score, higher the better. default uses transactionFee and some randomness\n    relayFilter,\n    //function: return false to filter out a relay. default uses minStake, minDelay\n    addScoreRandomness //function: return Math.random (0..1), to fairly distribute among relays with same score.\n    // (used by test to REMOVE the randomness, and make the test deterministic.\n\n  }) {\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this); //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n\n    this.relayFilter = relayFilter || (relay => relay.score != null && (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) && (!minStake || BN(relay.stake).gte(BN(minStake))));\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  defaultCalculateRelayScore(relay) {\n    //basic score is trasnaction fee (which is %)\n    //higher the better.\n    let score = 1000 - relay.transactionFee;\n    let failedRelay = this.failedRelays[relay.relayUrl];\n\n    if (failedRelay) {\n      const elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n      if (elapsed < this.relayTimeoutGrace) score -= 10; //relay failed to answer lately. demote.\n      else delete this.failedRelays[relay.relayUrl];\n    }\n\n    return score;\n  } //compare relay scores.\n  // if they are the same, use addScoreRandomness to shuffle them..\n\n\n  compareRelayScores(r1, r2) {\n    let diff = r2.score - r1.score;\n    if (diff) return diff;\n    return this.addScoreRandomness() - 0.5;\n  }\n  /**\n   *\n   * @param {*} relayHubInstance\n   */\n\n\n  setHub(relayHubInstance) {\n    if (this.relayHubInstance !== relayHubInstance) {\n      this.filteredRelays = [];\n    }\n\n    this.relayHubInstance = relayHubInstance;\n    this.addedAndRemovedSignatures = this.relayHubInstance.options.jsonInterface.filter(e => e.name === 'RelayAdded' || e.name === 'RelayRemoved').map(abi.encodeEventSignature);\n  }\n\n  async newActiveRelayPinger(fromBlock, gasPrice) {\n    if (typeof this.relayHubInstance === 'undefined') {\n      throw new Error('Must call to setHub first!');\n    }\n\n    if (this.filteredRelays.length == 0 || this.fromBlock !== fromBlock) {\n      this.fromBlock = fromBlock;\n      await this.fetchRelaysAdded();\n    }\n\n    return this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose);\n  }\n\n  createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n  }\n  /**\n   * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n   * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n   */\n\n\n  async fetchRelaysAdded() {\n    let activeRelays = {};\n    let fromBlock = this.fromBlock || 2;\n    let addedAndRemovedEvents = await this.relayHubInstance.getPastEvents('allEvents', {\n      fromBlock: fromBlock,\n      topics: [this.addedAndRemovedSignatures]\n    });\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: found ' + addedAndRemovedEvents.length + ' events');\n    } //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n    //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n\n\n    for (var index in addedAndRemovedEvents) {\n      let event = addedAndRemovedEvents[index];\n\n      if (event.event === 'RelayAdded') {\n        let args = event.returnValues;\n        let relay = {\n          address: args.relay,\n          relayUrl: args.url,\n          transactionFee: args.transactionFee,\n          stake: args.stake,\n          unstakeDelay: args.unstakeDelay\n        };\n        relay.score = this.calculateRelayScore(relay);\n        activeRelays[args.relay] = relay;\n      } else if (event.event === 'RelayRemoved') {\n        delete activeRelays[event.returnValues.relay];\n      }\n    }\n\n    const origRelays = Object.values(activeRelays);\n\n    if (origRelays.length === 0) {\n      throw new Error(`No relayers registered in the requested hub at ${this.relayHubInstance.options.address}`);\n    }\n\n    const filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n\n    if (filteredRelays.length == 0) {\n      throw new Error('No relayers elligible after filtering. Available relayers:\\n' + origRelays.map(r => ` score=${r.score} txFee=${r.transactionFee} stake=${r.stake} unstakeDelay=${r.unstakeDelay} address=${r.address} url=${r.relayUrl}`));\n    }\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: after filtering have ' + filteredRelays.length + ' active relays');\n    }\n\n    this.filteredRelays = filteredRelays;\n    this.isInitialized = true;\n    return filteredRelays;\n  }\n\n}\n\nmodule.exports = ServerHelper;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/test1/node_modules/@openzeppelin/gsn-provider/src/tabookey-gasless/ServerHelper.js"],"names":["BN","require","utils","toBN","abi","DEFAULT_RELAY_TIMEOUT_GRACE_SEC","ActiveRelayPinger","constructor","filteredRelays","httpSend","gasPrice","verbose","remainingRelays","slice","pingedRelays","relaysCount","length","errors","nextRelay","firstRelayToRespond","bulkSize","Math","min","console","log","JSON","stringify","raceToSuccess","map","relay","getRelayAddressPing","relayUrl","transactionFee","e","filter","a","self","Promise","resolve","reject","callback","error","body","message","toString","Ready","MinGasPrice","Object","assign","err","send","promises","numRejected","forEach","promise","then","res","catch","push","ServerHelper","failedRelays","minStake","minDelay","relayTimeoutGrace","calculateRelayScore","relayFilter","addScoreRandomness","random","defaultCalculateRelayScore","bind","score","unstakeDelay","gte","stake","isInitialized","failedRelay","elapsed","Date","getTime","lastError","compareRelayScores","r1","r2","diff","setHub","relayHubInstance","addedAndRemovedSignatures","options","jsonInterface","name","encodeEventSignature","newActiveRelayPinger","fromBlock","Error","fetchRelaysAdded","createActiveRelayPinger","activeRelays","addedAndRemovedEvents","getPastEvents","topics","index","event","args","returnValues","address","url","origRelays","values","sort","r","module","exports"],"mappings":"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","sourcesContent":["const BN = require('web3').utils.toBN;\nconst abi = require('web3-eth-abi');\n\n//relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\nconst DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nclass ActiveRelayPinger {\n  // TODO: 'httpSend' should be on a network layer\n  constructor(filteredRelays, httpSend, gasPrice, verbose) {\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n    this.errors = [];\n  }\n\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n  async nextRelay() {\n    if (this.remainingRelays.length === 0) {\n      return null;\n    }\n\n    let firstRelayToRespond;\n    for (; !firstRelayToRespond && this.remainingRelays.length; ) {\n      let bulkSize = Math.min(3, this.remainingRelays.length);\n      try {\n        let slice = this.remainingRelays.slice(0, bulkSize);\n        if (this.verbose) {\n          console.log('nextRelay: find fastest relay from: ' + JSON.stringify(slice));\n        }\n        firstRelayToRespond = await this.raceToSuccess(\n          slice.map(relay => this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, this.gasPrice)),\n        );\n        if (this.verbose) {\n          console.log('race finished with a champion: ' + firstRelayToRespond.relayUrl);\n        }\n      } catch (e) {\n        if (this.verbose) {\n          console.log('One batch of relays failed, last error: ', e);\n        }\n        //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n        this.remainingRelays = this.remainingRelays.slice(bulkSize);\n      }\n    }\n\n    this.remainingRelays = this.remainingRelays.filter(a => a.relayUrl !== firstRelayToRespond.relayUrl);\n    this.pingedRelays++;\n    return firstRelayToRespond;\n  }\n\n  /**\n   * @returns JSON response from the relay server, but adds the requested URL to it:\n   * { relayUrl: url,\n   *   transactionFee: fee,\n   *   RelayServerAddress: address,\n   *   Ready: bool,   //should ignore relays with \"false\"\n   *   MinGasPrice:   //minimum gas requirement by this relay.\n   * }\n   */\n  async getRelayAddressPing(relayUrl, transactionFee, gasPrice) {\n    let self = this;\n    return new Promise(function(resolve, reject) {\n      let callback = function(error, body) {\n        if (error) {\n          reject(`Error querying relayer ${relayUrl}: ${error.message || error.error || error.toString()}`);\n          return;\n        }\n        if (!body) {\n          reject(`Empty response from relayer ${relayUrl}`);\n          return;\n        }\n        if (!body.Ready) {\n          reject(`Relayer ${relayUrl} is not ready`);\n          return;\n        }\n        if (body.MinGasPrice > gasPrice) {\n          reject(\n            `Relayer ${relayUrl} requires a minimum gas price of ${body.MinGasPrice} which is over this transaction gas price (${gasPrice})`,\n          );\n          return;\n        }\n        try {\n          //add extra attributes (relayUrl, transactionFee)\n          Object.assign(body, { relayUrl, transactionFee });\n          resolve(body);\n        } catch (err) {\n          reject(err);\n        }\n      };\n      if (self.verbose) {\n        console.log('getRelayAddressPing URL: ' + relayUrl);\n      }\n      self.httpSend.send(relayUrl + '/getaddr', {}, callback);\n    });\n  }\n\n  /**\n   * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n   * Resolves once any promise resolves, ignores the rest, ignores rejections\n   */\n  async raceToSuccess(promises) {\n    let numRejected = 0;\n    return new Promise((resolve, reject) =>\n      promises.forEach(promise =>\n        promise\n          .then(res => {\n            resolve(res);\n          })\n          .catch(err => {\n            this.errors.push(err);\n            if (++numRejected === promises.length) {\n              reject('No response matched filter from any server: ' + err);\n            }\n          }),\n      ),\n    );\n  }\n}\n\nclass ServerHelper {\n  constructor(\n    httpSend,\n    failedRelays,\n    {\n      verbose,\n      minStake,\n      minDelay, //params for relayFilter: filter out this relay if unstakeDelay or stake are too low.\n      relayTimeoutGrace, //ignore score drop of a relay after this time (seconds)\n      calculateRelayScore, //function: return relay score, higher the better. default uses transactionFee and some randomness\n      relayFilter, //function: return false to filter out a relay. default uses minStake, minDelay\n      addScoreRandomness, //function: return Math.random (0..1), to fairly distribute among relays with same score.\n      // (used by test to REMOVE the randomness, and make the test deterministic.\n    },\n  ) {\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this);\n\n    //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n    this.relayFilter =\n      relayFilter ||\n      (relay =>\n        relay.score != null &&\n        (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) &&\n        (!minStake || BN(relay.stake).gte(BN(minStake))));\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  defaultCalculateRelayScore(relay) {\n    //basic score is trasnaction fee (which is %)\n    //higher the better.\n    let score = 1000 - relay.transactionFee;\n\n    let failedRelay = this.failedRelays[relay.relayUrl];\n    if (failedRelay) {\n      const elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n      if (elapsed < this.relayTimeoutGrace) score -= 10;\n      //relay failed to answer lately. demote.\n      else delete this.failedRelays[relay.relayUrl];\n    }\n\n    return score;\n  }\n\n  //compare relay scores.\n  // if they are the same, use addScoreRandomness to shuffle them..\n  compareRelayScores(r1, r2) {\n    let diff = r2.score - r1.score;\n    if (diff) return diff;\n    return this.addScoreRandomness() - 0.5;\n  }\n\n  /**\n   *\n   * @param {*} relayHubInstance\n   */\n  setHub(relayHubInstance) {\n    if (this.relayHubInstance !== relayHubInstance) {\n      this.filteredRelays = [];\n    }\n    this.relayHubInstance = relayHubInstance;\n    this.addedAndRemovedSignatures = this.relayHubInstance.options.jsonInterface\n      .filter(e => e.name === 'RelayAdded' || e.name === 'RelayRemoved')\n      .map(abi.encodeEventSignature);\n  }\n\n  async newActiveRelayPinger(fromBlock, gasPrice) {\n    if (typeof this.relayHubInstance === 'undefined') {\n      throw new Error('Must call to setHub first!');\n    }\n    if (this.filteredRelays.length == 0 || this.fromBlock !== fromBlock) {\n      this.fromBlock = fromBlock;\n      await this.fetchRelaysAdded();\n    }\n    return this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose);\n  }\n\n  createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n  }\n\n  /**\n   * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n   * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n   */\n  async fetchRelaysAdded() {\n    let activeRelays = {};\n    let fromBlock = this.fromBlock || 2;\n    let addedAndRemovedEvents = await this.relayHubInstance.getPastEvents('allEvents', {\n      fromBlock: fromBlock,\n      topics: [this.addedAndRemovedSignatures],\n    });\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: found ' + addedAndRemovedEvents.length + ' events');\n    }\n    //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n    //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n    for (var index in addedAndRemovedEvents) {\n      let event = addedAndRemovedEvents[index];\n      if (event.event === 'RelayAdded') {\n        let args = event.returnValues;\n        let relay = {\n          address: args.relay,\n          relayUrl: args.url,\n          transactionFee: args.transactionFee,\n          stake: args.stake,\n          unstakeDelay: args.unstakeDelay,\n        };\n        relay.score = this.calculateRelayScore(relay);\n        activeRelays[args.relay] = relay;\n      } else if (event.event === 'RelayRemoved') {\n        delete activeRelays[event.returnValues.relay];\n      }\n    }\n\n    const origRelays = Object.values(activeRelays);\n    if (origRelays.length === 0) {\n      throw new Error(`No relayers registered in the requested hub at ${this.relayHubInstance.options.address}`);\n    }\n\n    const filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n    if (filteredRelays.length == 0) {\n      throw new Error(\n        'No relayers elligible after filtering. Available relayers:\\n' +\n          origRelays.map(\n            r =>\n              ` score=${r.score} txFee=${r.transactionFee} stake=${r.stake} unstakeDelay=${r.unstakeDelay} address=${r.address} url=${r.relayUrl}`,\n          ),\n      );\n    }\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: after filtering have ' + filteredRelays.length + ' active relays');\n    }\n\n    this.filteredRelays = filteredRelays;\n    this.isInitialized = true;\n    return filteredRelays;\n  }\n}\n\nmodule.exports = ServerHelper;\n"]},"metadata":{},"sourceType":"script"}