{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('ethereumjs-wallet'),\n    fromPrivateKey = _require.fromPrivateKey;\n\nvar _require2 = require('./utils'),\n    callAsJsonRpc = _require2.callAsJsonRpc;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar sigUtil = require('eth-sig-util');\n\nvar EthereumTx = require('ethereumjs-tx');\n\nvar PrivateKeyProvider = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function PrivateKeyProvider(base, privateKey) {\n    _classCallCheck(this, PrivateKeyProvider);\n\n    // Build ethereumjs-wallet from privateKey\n    this.wallet = this._getWalletFromPrivateKey(privateKey);\n    this.address = ethUtil.toChecksumAddress(ethUtil.bufferToHex(this.wallet.getAddress())); // Patch base provider if needed\n\n    this.baseSend = (base.sendAsync || base.send).bind(base);\n    this.sendAsync = this.send.bind(this);\n    this.baseProvider = base;\n    this.messageId = 0;\n    this.isPrivateKeyProvider = true;\n  }\n\n  _createClass(PrivateKeyProvider, [{\n    key: \"send\",\n    value: function send(payload, callback) {\n      var from, data, txParams, signature;\n      var id = payload.id;\n\n      switch (payload.method) {\n        case 'eth_accounts':\n          callAsJsonRpc(this.ethAccounts.bind(this), [], id, callback);\n          break;\n\n        case 'eth_sign':\n          var _payload$params = _slicedToArray(payload.params, 2);\n\n          from = _payload$params[0];\n          data = _payload$params[1];\n          callAsJsonRpc(this.ethSign.bind(this), [from, data], id, callback);\n          break;\n\n        case 'eth_signTransaction':\n          var _payload$params2 = _slicedToArray(payload.params, 1);\n\n          txParams = _payload$params2[0];\n          callAsJsonRpc(this.ethSignTransaction.bind(this), [txParams], id, callback, function (signedTx) {\n            return {\n              tx: txParams,\n              raw: signedTx\n            };\n          });\n          break;\n\n        case 'eth_signTypedData':\n          var _payload$params3 = _slicedToArray(payload.params, 2);\n\n          from = _payload$params3[0];\n          data = _payload$params3[1];\n          callAsJsonRpc(this.ethSignTypedData.bind(this), [from, data], id, callback);\n          break;\n\n        case 'eth_sendTransaction':\n          // TODO: Implement this method before releasing this as a standalone provider\n          return this.baseSend(payload, callback);\n\n        case 'personal_sign':\n          var _payload$params4 = _slicedToArray(payload.params, 2);\n\n          data = _payload$params4[0];\n          from = _payload$params4[1];\n          callAsJsonRpc(this.personalSign.bind(this), [from, data], id, callback);\n          break;\n\n        case 'personal_ecRecover':\n          var _payload$params5 = _slicedToArray(payload.params, 2);\n\n          data = _payload$params5[0];\n          signature = _payload$params5[1];\n          callAsJsonRpc(this.personalEcRecover.bind(this), [data, signature], id, callback);\n          break;\n\n        default:\n          return this.baseSend(payload, callback);\n      }\n    }\n  }, {\n    key: \"ethAccounts\",\n    value: function () {\n      var _ethAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", [this.address]);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function ethAccounts() {\n        return _ethAccounts.apply(this, arguments);\n      }\n\n      return ethAccounts;\n    }() // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n  }, {\n    key: \"ethSign\",\n    value: function () {\n      var _ethSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(signer, data) {\n        var dataBuff, msgHash, sig;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error('Data to sign cannot be null');\n\n              case 3:\n                dataBuff = ethUtil.toBuffer(data);\n                msgHash = ethUtil.hashPersonalMessage(dataBuff);\n                sig = ethUtil.ecsign(msgHash, this.wallet.getPrivateKey());\n                return _context2.abrupt(\"return\", ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s)));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function ethSign(_x, _x2) {\n        return _ethSign.apply(this, arguments);\n      }\n\n      return ethSign;\n    }()\n  }, {\n    key: \"ethSignTypedData\",\n    value: function () {\n      var _ethSignTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(signer, data) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error('Data to sign cannot be null');\n\n              case 3:\n                return _context3.abrupt(\"return\", sigUtil.signTypedData(this.wallet.getPrivateKey(), {\n                  data: data\n                }));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function ethSignTypedData(_x3, _x4) {\n        return _ethSignTypedData.apply(this, arguments);\n      }\n\n      return ethSignTypedData;\n    }()\n  }, {\n    key: \"personalSign\",\n    value: function () {\n      var _personalSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(signer, data) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error('Data to sign cannot be null');\n\n              case 3:\n                return _context4.abrupt(\"return\", sigUtil.personalSign(this.wallet.getPrivateKey(), {\n                  data: data\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function personalSign(_x5, _x6) {\n        return _personalSign.apply(this, arguments);\n      }\n\n      return personalSign;\n    }()\n  }, {\n    key: \"personalEcRecover\",\n    value: function () {\n      var _personalEcRecover = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data, sig) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (sig) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('Signature for ecRecover cannot be null');\n\n              case 2:\n                if (data) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new Error('Data for ecRecover cannot be null');\n\n              case 4:\n                return _context5.abrupt(\"return\", sigUtil.recoverPersonalSignature({\n                  data: data,\n                  sig: sig\n                }));\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function personalEcRecover(_x7, _x8) {\n        return _personalEcRecover.apply(this, arguments);\n      }\n\n      return personalEcRecover;\n    }() // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n  }, {\n    key: \"ethSignTransaction\",\n    value: function () {\n      var _ethSignTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(txData) {\n        var privateKey, tx;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._validateSigner(txData.from); // TODO: Fill in gas, gasPrice, and nonce if missing instead of failing\n\n\n                if (!(!txData.gas && !txData.gasLimit)) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Gas limit for transaction is required (\".concat(txData, \")\"));\n\n              case 3:\n                if (txData.gasPrice) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Gas price for transaction is required (\".concat(txData, \")\"));\n\n              case 5:\n                if (txData.nonce) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Nonce for transaction is required (\".concat(txData, \")\"));\n\n              case 7:\n                // Format gas, value, and data for ethereum-tx\n                if (txData.gas !== undefined) txData.gasLimit = txData.gas;\n                txData.value = txData.value || '0x00';\n                txData.data = ethUtil.addHexPrefix(txData.data); // Build ethereum-tx object and sign it\n\n                privateKey = this.wallet.getPrivateKey();\n                tx = new EthereumTx(txData);\n                tx.sign(privateKey);\n                return _context6.abrupt(\"return\", ethUtil.bufferToHex(tx.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function ethSignTransaction(_x9) {\n        return _ethSignTransaction.apply(this, arguments);\n      }\n\n      return ethSignTransaction;\n    }()\n  }, {\n    key: \"_validateSigner\",\n    value: function _validateSigner(signer) {\n      if (!signer) {\n        throw new Error(\"Signer address is required\");\n      }\n\n      if (signer.toLowerCase() !== this.address.toLowerCase()) {\n        throw new Error(\"Unknown signer \".concat(signer, \" (current signer is \").concat(this.address, \")\"));\n      }\n    }\n  }, {\n    key: \"_getWalletFromPrivateKey\",\n    value: function _getWalletFromPrivateKey(privateKey) {\n      if (!privateKey) throw new Error('Private key must be set'); // This is an ethereumjs-wallet already\n\n      if (privateKey.getPrivateKey && privateKey.getAddress) return privateKey; // This is an object that contains the private key\n\n      if (privateKey.privateKey) privateKey = privateKey.privateKey; // Transform the private key into a buffer\n\n      var keyBuffer = typeof privateKey === 'string' ? new Buffer(privateKey.replace(/^0x/, ''), 'hex') : privateKey; // Build the wallet from the key\n\n      return fromPrivateKey(keyBuffer);\n    }\n  }]);\n\n  return PrivateKeyProvider;\n}(); // Copied from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n\nfunction concatSig(v, r, s) {\n  r = ethUtil.fromSigned(r);\n  s = ethUtil.fromSigned(s);\n  v = ethUtil.bufferToInt(v);\n  r = ethUtil.toUnsigned(r).toString('hex').padStart(64, 0);\n  s = ethUtil.toUnsigned(s).toString('hex').padStart(64, 0);\n  v = ethUtil.stripHexPrefix(ethUtil.intToHex(v));\n  return ethUtil.addHexPrefix(r.concat(s, v).toString('hex'));\n}\n\nmodule.exports = PrivateKeyProvider;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/test1/node_modules/@openzeppelin/gsn-provider/src/PrivateKeyProvider.js"],"names":["require","fromPrivateKey","callAsJsonRpc","ethUtil","sigUtil","EthereumTx","PrivateKeyProvider","base","privateKey","wallet","_getWalletFromPrivateKey","address","toChecksumAddress","bufferToHex","getAddress","baseSend","sendAsync","send","bind","baseProvider","messageId","isPrivateKeyProvider","payload","callback","from","data","txParams","signature","id","method","ethAccounts","params","ethSign","ethSignTransaction","signedTx","tx","raw","ethSignTypedData","personalSign","personalEcRecover","signer","_validateSigner","Error","dataBuff","toBuffer","msgHash","hashPersonalMessage","sig","ecsign","getPrivateKey","concatSig","v","r","s","signTypedData","recoverPersonalSignature","txData","gas","gasLimit","gasPrice","nonce","undefined","value","addHexPrefix","sign","serialize","toLowerCase","keyBuffer","Buffer","replace","fromSigned","bufferToInt","toUnsigned","toString","padStart","stripHexPrefix","intToHex","concat","module","exports"],"mappings":"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","sourcesContent":["const { fromPrivateKey } = require('ethereumjs-wallet');\nconst { callAsJsonRpc } = require('./utils');\nconst ethUtil = require('ethereumjs-util');\nconst sigUtil = require('eth-sig-util');\nconst EthereumTx = require('ethereumjs-tx');\n\nclass PrivateKeyProvider {\n  constructor(base, privateKey) {\n    // Build ethereumjs-wallet from privateKey\n    this.wallet = this._getWalletFromPrivateKey(privateKey);\n    this.address = ethUtil.toChecksumAddress(ethUtil.bufferToHex(this.wallet.getAddress()));\n\n    // Patch base provider if needed\n    this.baseSend = (base.sendAsync || base.send).bind(base);\n    this.sendAsync = this.send.bind(this);\n    this.baseProvider = base;\n\n    this.messageId = 0;\n    this.isPrivateKeyProvider = true;\n  }\n\n  send(payload, callback) {\n    let from, data, txParams, signature;\n    const id = payload.id;\n\n    switch (payload.method) {\n      case 'eth_accounts':\n        callAsJsonRpc(this.ethAccounts.bind(this), [], id, callback);\n        break;\n\n      case 'eth_sign':\n        [from, data] = payload.params;\n        callAsJsonRpc(this.ethSign.bind(this), [from, data], id, callback);\n        break;\n\n      case 'eth_signTransaction':\n        [txParams] = payload.params;\n        callAsJsonRpc(this.ethSignTransaction.bind(this), [txParams], id, callback, signedTx => ({\n          tx: txParams,\n          raw: signedTx,\n        }));\n        break;\n\n      case 'eth_signTypedData':\n        [from, data] = payload.params;\n        callAsJsonRpc(this.ethSignTypedData.bind(this), [from, data], id, callback);\n        break;\n\n      case 'eth_sendTransaction':\n        // TODO: Implement this method before releasing this as a standalone provider\n        return this.baseSend(payload, callback);\n\n      case 'personal_sign':\n        [data, from] = payload.params;\n        callAsJsonRpc(this.personalSign.bind(this), [from, data], id, callback);\n        break;\n\n      case 'personal_ecRecover':\n        [data, signature] = payload.params;\n        callAsJsonRpc(this.personalEcRecover.bind(this), [data, signature], id, callback);\n        break;\n\n      default:\n        return this.baseSend(payload, callback);\n    }\n  }\n\n  async ethAccounts() {\n    return [this.address];\n  }\n\n  // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n  async ethSign(signer, data) {\n    this._validateSigner(signer);\n    if (!data) throw new Error('Data to sign cannot be null');\n\n    const dataBuff = ethUtil.toBuffer(data);\n    const msgHash = ethUtil.hashPersonalMessage(dataBuff);\n    const sig = ethUtil.ecsign(msgHash, this.wallet.getPrivateKey());\n    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));\n  }\n\n  async ethSignTypedData(signer, data) {\n    this._validateSigner(signer);\n    if (!data) throw new Error('Data to sign cannot be null');\n    return sigUtil.signTypedData(this.wallet.getPrivateKey(), { data });\n  }\n\n  async personalSign(signer, data) {\n    this._validateSigner(signer);\n    if (!data) throw new Error('Data to sign cannot be null');\n    return sigUtil.personalSign(this.wallet.getPrivateKey(), { data });\n  }\n\n  async personalEcRecover(data, sig) {\n    if (!sig) throw new Error('Signature for ecRecover cannot be null');\n    if (!data) throw new Error('Data for ecRecover cannot be null');\n    return sigUtil.recoverPersonalSignature({ data, sig });\n  }\n\n  // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n  async ethSignTransaction(txData) {\n    this._validateSigner(txData.from);\n\n    // TODO: Fill in gas, gasPrice, and nonce if missing instead of failing\n    if (!txData.gas && !txData.gasLimit) throw new Error(`Gas limit for transaction is required (${txData})`);\n    if (!txData.gasPrice) throw new Error(`Gas price for transaction is required (${txData})`);\n    if (!txData.nonce) throw new Error(`Nonce for transaction is required (${txData})`);\n\n    // Format gas, value, and data for ethereum-tx\n    if (txData.gas !== undefined) txData.gasLimit = txData.gas;\n    txData.value = txData.value || '0x00';\n    txData.data = ethUtil.addHexPrefix(txData.data);\n\n    // Build ethereum-tx object and sign it\n    const privateKey = this.wallet.getPrivateKey();\n    const tx = new EthereumTx(txData);\n    tx.sign(privateKey);\n    return ethUtil.bufferToHex(tx.serialize());\n  }\n\n  _validateSigner(signer) {\n    if (!signer) {\n      throw new Error(`Signer address is required`);\n    }\n    if (signer.toLowerCase() !== this.address.toLowerCase()) {\n      throw new Error(`Unknown signer ${signer} (current signer is ${this.address})`);\n    }\n  }\n\n  _getWalletFromPrivateKey(privateKey) {\n    if (!privateKey) throw new Error('Private key must be set');\n    // This is an ethereumjs-wallet already\n    if (privateKey.getPrivateKey && privateKey.getAddress) return privateKey;\n    // This is an object that contains the private key\n    if (privateKey.privateKey) privateKey = privateKey.privateKey;\n    // Transform the private key into a buffer\n    const keyBuffer = typeof privateKey === 'string' ? new Buffer(privateKey.replace(/^0x/, ''), 'hex') : privateKey;\n    // Build the wallet from the key\n    return fromPrivateKey(keyBuffer);\n  }\n}\n\n// Copied from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\nfunction concatSig(v, r, s) {\n  r = ethUtil.fromSigned(r);\n  s = ethUtil.fromSigned(s);\n  v = ethUtil.bufferToInt(v);\n  r = ethUtil\n    .toUnsigned(r)\n    .toString('hex')\n    .padStart(64, 0);\n  s = ethUtil\n    .toUnsigned(s)\n    .toString('hex')\n    .padStart(64, 0);\n  v = ethUtil.stripHexPrefix(ethUtil.intToHex(v));\n  return ethUtil.addHexPrefix(r.concat(s, v).toString('hex'));\n}\n\nmodule.exports = PrivateKeyProvider;\n"]},"metadata":{},"sourceType":"script"}