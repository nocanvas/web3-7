{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BN = require('web3').utils.toBN;\n\nvar abi = require('web3-eth-abi'); //relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\n\n\nvar DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nvar ActiveRelayPinger = /*#__PURE__*/function () {\n  \"use strict\";\n\n  // TODO: 'httpSend' should be on a network layer\n  function ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    _classCallCheck(this, ActiveRelayPinger);\n\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n    this.errors = [];\n  }\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  _createClass(ActiveRelayPinger, [{\n    key: \"nextRelay\",\n    value: function () {\n      var _nextRelay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var firstRelayToRespond, bulkSize, slice;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.remainingRelays.length === 0)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 2:\n                if (!(!firstRelayToRespond && this.remainingRelays.length)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                bulkSize = Math.min(3, this.remainingRelays.length);\n                _context.prev = 4;\n                slice = this.remainingRelays.slice(0, bulkSize);\n\n                if (this.verbose) {\n                  console.log('nextRelay: find fastest relay from: ' + JSON.stringify(slice));\n                }\n\n                _context.next = 9;\n                return this.raceToSuccess(slice.map(function (relay) {\n                  return _this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, _this.gasPrice);\n                }));\n\n              case 9:\n                firstRelayToRespond = _context.sent;\n\n                if (this.verbose) {\n                  console.log('race finished with a champion: ' + firstRelayToRespond.relayUrl);\n                }\n\n                _context.next = 17;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](4);\n\n                if (this.verbose) {\n                  console.log('One batch of relays failed, last error: ', _context.t0);\n                } //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n\n\n                this.remainingRelays = this.remainingRelays.slice(bulkSize);\n\n              case 17:\n                _context.next = 2;\n                break;\n\n              case 19:\n                this.remainingRelays = this.remainingRelays.filter(function (a) {\n                  return a.relayUrl !== firstRelayToRespond.relayUrl;\n                });\n                this.pingedRelays++;\n                return _context.abrupt(\"return\", firstRelayToRespond);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 13]]);\n      }));\n\n      function nextRelay() {\n        return _nextRelay.apply(this, arguments);\n      }\n\n      return nextRelay;\n    }()\n    /**\n     * @returns JSON response from the relay server, but adds the requested URL to it:\n     * { relayUrl: url,\n     *   transactionFee: fee,\n     *   RelayServerAddress: address,\n     *   Ready: bool,   //should ignore relays with \"false\"\n     *   MinGasPrice:   //minimum gas requirement by this relay.\n     * }\n     */\n\n  }, {\n    key: \"getRelayAddressPing\",\n    value: function () {\n      var _getRelayAddressPing = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(relayUrl, transactionFee, gasPrice) {\n        var self;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                self = this;\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var callback = function callback(error, body) {\n                    if (error) {\n                      reject(\"Error querying relayer \".concat(relayUrl, \": \").concat(error.message || error.error || error.toString()));\n                      return;\n                    }\n\n                    if (!body) {\n                      reject(\"Empty response from relayer \".concat(relayUrl));\n                      return;\n                    }\n\n                    if (!body.Ready) {\n                      reject(\"Relayer \".concat(relayUrl, \" is not ready\"));\n                      return;\n                    }\n\n                    if (body.MinGasPrice > gasPrice) {\n                      reject(\"Relayer \".concat(relayUrl, \" requires a minimum gas price of \").concat(body.MinGasPrice, \" which is over this transaction gas price (\").concat(gasPrice, \")\"));\n                      return;\n                    }\n\n                    try {\n                      //add extra attributes (relayUrl, transactionFee)\n                      Object.assign(body, {\n                        relayUrl: relayUrl,\n                        transactionFee: transactionFee\n                      });\n                      resolve(body);\n                    } catch (err) {\n                      reject(err);\n                    }\n                  };\n\n                  if (self.verbose) {\n                    console.log('getRelayAddressPing URL: ' + relayUrl);\n                  }\n\n                  self.httpSend.send(relayUrl + '/getaddr', {}, callback);\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getRelayAddressPing(_x, _x2, _x3) {\n        return _getRelayAddressPing.apply(this, arguments);\n      }\n\n      return getRelayAddressPing;\n    }()\n    /**\n     * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n     * Resolves once any promise resolves, ignores the rest, ignores rejections\n     */\n\n  }, {\n    key: \"raceToSuccess\",\n    value: function () {\n      var _raceToSuccess = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(promises) {\n        var _this2 = this;\n\n        var numRejected;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                numRejected = 0;\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return promises.forEach(function (promise) {\n                    return promise.then(function (res) {\n                      resolve(res);\n                    }).catch(function (err) {\n                      _this2.errors.push(err);\n\n                      if (++numRejected === promises.length) {\n                        reject('No response matched filter from any server: ' + err);\n                      }\n                    });\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function raceToSuccess(_x4) {\n        return _raceToSuccess.apply(this, arguments);\n      }\n\n      return raceToSuccess;\n    }()\n  }]);\n\n  return ActiveRelayPinger;\n}();\n\nvar ServerHelper = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function ServerHelper(httpSend, failedRelays, _ref) {\n    var verbose = _ref.verbose,\n        minStake = _ref.minStake,\n        minDelay = _ref.minDelay,\n        relayTimeoutGrace = _ref.relayTimeoutGrace,\n        calculateRelayScore = _ref.calculateRelayScore,\n        relayFilter = _ref.relayFilter,\n        addScoreRandomness = _ref.addScoreRandomness;\n\n    _classCallCheck(this, ServerHelper);\n\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this); //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n\n    this.relayFilter = relayFilter || function (relay) {\n      return relay.score != null && (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) && (!minStake || BN(relay.stake).gte(BN(minStake)));\n    };\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  _createClass(ServerHelper, [{\n    key: \"defaultCalculateRelayScore\",\n    value: function defaultCalculateRelayScore(relay) {\n      //basic score is trasnaction fee (which is %)\n      //higher the better.\n      var score = 1000 - relay.transactionFee;\n      var failedRelay = this.failedRelays[relay.relayUrl];\n\n      if (failedRelay) {\n        var elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n        if (elapsed < this.relayTimeoutGrace) score -= 10; //relay failed to answer lately. demote.\n        else delete this.failedRelays[relay.relayUrl];\n      }\n\n      return score;\n    } //compare relay scores.\n    // if they are the same, use addScoreRandomness to shuffle them..\n\n  }, {\n    key: \"compareRelayScores\",\n    value: function compareRelayScores(r1, r2) {\n      var diff = r2.score - r1.score;\n      if (diff) return diff;\n      return this.addScoreRandomness() - 0.5;\n    }\n    /**\n     *\n     * @param {*} relayHubInstance\n     */\n\n  }, {\n    key: \"setHub\",\n    value: function setHub(relayHubInstance) {\n      if (this.relayHubInstance !== relayHubInstance) {\n        this.filteredRelays = [];\n      }\n\n      this.relayHubInstance = relayHubInstance;\n      this.addedAndRemovedSignatures = this.relayHubInstance.options.jsonInterface.filter(function (e) {\n        return e.name === 'RelayAdded' || e.name === 'RelayRemoved';\n      }).map(abi.encodeEventSignature);\n    }\n  }, {\n    key: \"newActiveRelayPinger\",\n    value: function () {\n      var _newActiveRelayPinger = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(fromBlock, gasPrice) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof this.relayHubInstance === 'undefined')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Must call to setHub first!');\n\n              case 2:\n                if (!(this.filteredRelays.length == 0 || this.fromBlock !== fromBlock)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                this.fromBlock = fromBlock;\n                _context4.next = 6;\n                return this.fetchRelaysAdded();\n\n              case 6:\n                return _context4.abrupt(\"return\", this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose));\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function newActiveRelayPinger(_x5, _x6) {\n        return _newActiveRelayPinger.apply(this, arguments);\n      }\n\n      return newActiveRelayPinger;\n    }()\n  }, {\n    key: \"createActiveRelayPinger\",\n    value: function createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n      return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n    }\n    /**\n     * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n     * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n     */\n\n  }, {\n    key: \"fetchRelaysAdded\",\n    value: function () {\n      var _fetchRelaysAdded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var activeRelays, fromBlock, addedAndRemovedEvents, index, event, args, relay, origRelays, filteredRelays;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                activeRelays = {};\n                fromBlock = this.fromBlock || 2;\n                _context5.next = 4;\n                return this.relayHubInstance.getPastEvents('allEvents', {\n                  fromBlock: fromBlock,\n                  topics: [this.addedAndRemovedSignatures]\n                });\n\n              case 4:\n                addedAndRemovedEvents = _context5.sent;\n\n                if (this.verbose) {\n                  console.log('fetchRelaysAdded: found ' + addedAndRemovedEvents.length + ' events');\n                } //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n                //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n\n\n                for (index in addedAndRemovedEvents) {\n                  event = addedAndRemovedEvents[index];\n\n                  if (event.event === 'RelayAdded') {\n                    args = event.returnValues;\n                    relay = {\n                      address: args.relay,\n                      relayUrl: args.url,\n                      transactionFee: args.transactionFee,\n                      stake: args.stake,\n                      unstakeDelay: args.unstakeDelay\n                    };\n                    relay.score = this.calculateRelayScore(relay);\n                    activeRelays[args.relay] = relay;\n                  } else if (event.event === 'RelayRemoved') {\n                    delete activeRelays[event.returnValues.relay];\n                  }\n                }\n\n                origRelays = Object.values(activeRelays);\n\n                if (!(origRelays.length === 0)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw new Error(\"No relayers registered in the requested hub at \".concat(this.relayHubInstance.options.address));\n\n              case 10:\n                filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n\n                if (!(filteredRelays.length == 0)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                throw new Error('No relayers elligible after filtering. Available relayers:\\n' + origRelays.map(function (r) {\n                  return \" score=\".concat(r.score, \" txFee=\").concat(r.transactionFee, \" stake=\").concat(r.stake, \" unstakeDelay=\").concat(r.unstakeDelay, \" address=\").concat(r.address, \" url=\").concat(r.relayUrl);\n                }));\n\n              case 13:\n                if (this.verbose) {\n                  console.log('fetchRelaysAdded: after filtering have ' + filteredRelays.length + ' active relays');\n                }\n\n                this.filteredRelays = filteredRelays;\n                this.isInitialized = true;\n                return _context5.abrupt(\"return\", filteredRelays);\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function fetchRelaysAdded() {\n        return _fetchRelaysAdded.apply(this, arguments);\n      }\n\n      return fetchRelaysAdded;\n    }()\n  }]);\n\n  return ServerHelper;\n}();\n\nmodule.exports = ServerHelper;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/test1/node_modules/@openzeppelin/gsn-provider/src/tabookey-gasless/ServerHelper.js"],"names":["BN","require","utils","toBN","abi","DEFAULT_RELAY_TIMEOUT_GRACE_SEC","ActiveRelayPinger","filteredRelays","httpSend","gasPrice","verbose","remainingRelays","slice","pingedRelays","relaysCount","length","errors","firstRelayToRespond","bulkSize","Math","min","console","log","JSON","stringify","raceToSuccess","map","relay","getRelayAddressPing","relayUrl","transactionFee","filter","a","self","Promise","resolve","reject","callback","error","body","message","toString","Ready","MinGasPrice","Object","assign","err","send","promises","numRejected","forEach","promise","then","res","catch","push","ServerHelper","failedRelays","minStake","minDelay","relayTimeoutGrace","calculateRelayScore","relayFilter","addScoreRandomness","random","defaultCalculateRelayScore","bind","score","unstakeDelay","gte","stake","isInitialized","failedRelay","elapsed","Date","getTime","lastError","r1","r2","diff","relayHubInstance","addedAndRemovedSignatures","options","jsonInterface","e","name","encodeEventSignature","fromBlock","Error","fetchRelaysAdded","createActiveRelayPinger","activeRelays","getPastEvents","topics","addedAndRemovedEvents","index","event","args","returnValues","address","url","origRelays","values","sort","compareRelayScores","r","module","exports"],"mappings":";;;;;;;;AAAA,IAAMA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAP,CAAgBC,KAAhB,CAAsBC,IAAjC;;AACA,IAAMC,GAAG,GAAGH,OAAO,CAAC,cAAD,CAAnB,C,CAEA;AACA;;;AACA,IAAMI,+BAA+B,GAAG,KAAK,EAA7C;;IAEMC,iB;;;AACJ;AACA,6BAAYC,cAAZ,EAA4BC,QAA5B,EAAsCC,QAAtC,EAAgDC,OAAhD,EAAyD;AAAA;;AACvD,SAAKC,eAAL,GAAuBJ,cAAc,CAACK,KAAf,EAAvB;AACA,SAAKJ,QAAL,GAAgBA,QAAhB;AACA,SAAKK,YAAL,GAAoB,CAApB;AACA,SAAKC,WAAL,GAAmBP,cAAc,CAACQ,MAAlC;AACA,SAAKN,QAAL,GAAgBA,QAAhB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKM,MAAL,GAAc,EAAd;AACD;AAED;AACF;AACA;AACA;;;;;;gFACE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,KAAKL,eAAL,CAAqBI,MAArB,KAAgC,CADtC;AAAA;AAAA;AAAA;;AAAA,iDAEW,IAFX;;AAAA;AAAA,sBAMS,CAACE,mBAAD,IAAwB,KAAKN,eAAL,CAAqBI,MANtD;AAAA;AAAA;AAAA;;AAOQG,gBAAAA,QAPR,GAOmBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAKT,eAAL,CAAqBI,MAAjC,CAPnB;AAAA;AASUH,gBAAAA,KATV,GASkB,KAAKD,eAAL,CAAqBC,KAArB,CAA2B,CAA3B,EAA8BM,QAA9B,CATlB;;AAUM,oBAAI,KAAKR,OAAT,EAAkB;AAChBW,kBAAAA,OAAO,CAACC,GAAR,CAAY,yCAAyCC,IAAI,CAACC,SAAL,CAAeZ,KAAf,CAArD;AACD;;AAZP;AAAA,uBAakC,KAAKa,aAAL,CAC1Bb,KAAK,CAACc,GAAN,CAAU,UAAAC,KAAK;AAAA,yBAAI,KAAI,CAACC,mBAAL,CAAyBD,KAAK,CAACE,QAA/B,EAAyCF,KAAK,CAACG,cAA/C,EAA+D,KAAI,CAACrB,QAApE,CAAJ;AAAA,iBAAf,CAD0B,CAblC;;AAAA;AAaMQ,gBAAAA,mBAbN;;AAgBM,oBAAI,KAAKP,OAAT,EAAkB;AAChBW,kBAAAA,OAAO,CAACC,GAAR,CAAY,oCAAoCL,mBAAmB,CAACY,QAApE;AACD;;AAlBP;AAAA;;AAAA;AAAA;AAAA;;AAoBM,oBAAI,KAAKnB,OAAT,EAAkB;AAChBW,kBAAAA,OAAO,CAACC,GAAR,CAAY,0CAAZ;AACD,iBAtBP,CAuBM;;;AACA,qBAAKX,eAAL,GAAuB,KAAKA,eAAL,CAAqBC,KAArB,CAA2BM,QAA3B,CAAvB;;AAxBN;AAAA;AAAA;;AAAA;AA4BE,qBAAKP,eAAL,GAAuB,KAAKA,eAAL,CAAqBoB,MAArB,CAA4B,UAAAC,CAAC;AAAA,yBAAIA,CAAC,CAACH,QAAF,KAAeZ,mBAAmB,CAACY,QAAvC;AAAA,iBAA7B,CAAvB;AACA,qBAAKhB,YAAL;AA7BF,iDA8BSI,mBA9BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAiCA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;0FACE,kBAA0BY,QAA1B,EAAoCC,cAApC,EAAoDrB,QAApD;AAAA;AAAA;AAAA;AAAA;AAAA;AACMwB,gBAAAA,IADN,GACa,IADb;AAAA,kDAES,IAAIC,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AAC3C,sBAAIC,QAAQ,GAAG,SAAXA,QAAW,CAASC,KAAT,EAAgBC,IAAhB,EAAsB;AACnC,wBAAID,KAAJ,EAAW;AACTF,sBAAAA,MAAM,kCAA2BP,QAA3B,eAAwCS,KAAK,CAACE,OAAN,IAAiBF,KAAK,CAACA,KAAvB,IAAgCA,KAAK,CAACG,QAAN,EAAxE,EAAN;AACA;AACD;;AACD,wBAAI,CAACF,IAAL,EAAW;AACTH,sBAAAA,MAAM,uCAAgCP,QAAhC,EAAN;AACA;AACD;;AACD,wBAAI,CAACU,IAAI,CAACG,KAAV,EAAiB;AACfN,sBAAAA,MAAM,mBAAYP,QAAZ,mBAAN;AACA;AACD;;AACD,wBAAIU,IAAI,CAACI,WAAL,GAAmBlC,QAAvB,EAAiC;AAC/B2B,sBAAAA,MAAM,mBACOP,QADP,8CACmDU,IAAI,CAACI,WADxD,wDACiHlC,QADjH,OAAN;AAGA;AACD;;AACD,wBAAI;AACF;AACAmC,sBAAAA,MAAM,CAACC,MAAP,CAAcN,IAAd,EAAoB;AAAEV,wBAAAA,QAAQ,EAARA,QAAF;AAAYC,wBAAAA,cAAc,EAAdA;AAAZ,uBAApB;AACAK,sBAAAA,OAAO,CAACI,IAAD,CAAP;AACD,qBAJD,CAIE,OAAOO,GAAP,EAAY;AACZV,sBAAAA,MAAM,CAACU,GAAD,CAAN;AACD;AACF,mBA1BD;;AA2BA,sBAAIb,IAAI,CAACvB,OAAT,EAAkB;AAChBW,oBAAAA,OAAO,CAACC,GAAR,CAAY,8BAA8BO,QAA1C;AACD;;AACDI,kBAAAA,IAAI,CAACzB,QAAL,CAAcuC,IAAd,CAAmBlB,QAAQ,GAAG,UAA9B,EAA0C,EAA1C,EAA8CQ,QAA9C;AACD,iBAhCM,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAqCA;AACF;AACA;AACA;;;;;oFACE,kBAAoBW,QAApB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACMC,gBAAAA,WADN,GACoB,CADpB;AAAA,kDAES,IAAIf,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV;AAAA,yBACjBY,QAAQ,CAACE,OAAT,CAAiB,UAAAC,OAAO;AAAA,2BACtBA,OAAO,CACJC,IADH,CACQ,UAAAC,GAAG,EAAI;AACXlB,sBAAAA,OAAO,CAACkB,GAAD,CAAP;AACD,qBAHH,EAIGC,KAJH,CAIS,UAAAR,GAAG,EAAI;AACZ,sBAAA,MAAI,CAAC9B,MAAL,CAAYuC,IAAZ,CAAiBT,GAAjB;;AACA,0BAAI,EAAEG,WAAF,KAAkBD,QAAQ,CAACjC,MAA/B,EAAuC;AACrCqB,wBAAAA,MAAM,CAAC,iDAAiDU,GAAlD,CAAN;AACD;AACF,qBATH,CADsB;AAAA,mBAAxB,CADiB;AAAA,iBAAZ,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;IAmBIU,Y;;;AACJ,wBACEhD,QADF,EAEEiD,YAFF,QAaE;AAAA,QATE/C,OASF,QATEA,OASF;AAAA,QAREgD,QAQF,QAREA,QAQF;AAAA,QAPEC,QAOF,QAPEA,QAOF;AAAA,QANEC,iBAMF,QANEA,iBAMF;AAAA,QALEC,mBAKF,QALEA,mBAKF;AAAA,QAJEC,WAIF,QAJEA,WAIF;AAAA,QAHEC,kBAGF,QAHEA,kBAGF;;AAAA;;AACA,SAAKvD,QAAL,GAAgBA,QAAhB;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAK+C,YAAL,GAAoBA,YAApB;AACA,SAAKG,iBAAL,GAAyBA,iBAAiB,IAAIvD,+BAA9C;AAEA,SAAK0D,kBAAL,GAA0BA,kBAAkB,IAAI5C,IAAI,CAAC6C,MAArD;AAEA,SAAKH,mBAAL,GAA2BA,mBAAmB,IAAI,KAAKI,0BAAL,CAAgCC,IAAhC,CAAqC,IAArC,CAAlD,CARA,CAUA;AACA;;AACA,SAAKJ,WAAL,GACEA,WAAW,IACV,UAAAnC,KAAK;AAAA,aACJA,KAAK,CAACwC,KAAN,IAAe,IAAf,KACC,CAACR,QAAD,IAAa3D,EAAE,CAAC2B,KAAK,CAACyC,YAAP,CAAF,CAAuBC,GAAvB,CAA2BrE,EAAE,CAAC2D,QAAD,CAA7B,CADd,MAEC,CAACD,QAAD,IAAa1D,EAAE,CAAC2B,KAAK,CAAC2C,KAAP,CAAF,CAAgBD,GAAhB,CAAoBrE,EAAE,CAAC0D,QAAD,CAAtB,CAFd,CADI;AAAA,KAFR;;AAOA,SAAKnD,cAAL,GAAsB,EAAtB;AACA,SAAKgE,aAAL,GAAqB,KAArB;AACA,SAAKjE,iBAAL,GAAyBA,iBAAzB;AACD;;;;WAED,oCAA2BqB,KAA3B,EAAkC;AAChC;AACA;AACA,UAAIwC,KAAK,GAAG,OAAOxC,KAAK,CAACG,cAAzB;AAEA,UAAI0C,WAAW,GAAG,KAAKf,YAAL,CAAkB9B,KAAK,CAACE,QAAxB,CAAlB;;AACA,UAAI2C,WAAJ,EAAiB;AACf,YAAMC,OAAO,GAAG,CAAC,IAAIC,IAAJ,GAAWC,OAAX,KAAuBH,WAAW,CAACI,SAApC,IAAiD,IAAjE;AACA,YAAIH,OAAO,GAAG,KAAKb,iBAAnB,EAAsCO,KAAK,IAAI,EAAT,CAAtC,CACA;AADA,aAEK,OAAO,KAAKV,YAAL,CAAkB9B,KAAK,CAACE,QAAxB,CAAP;AACN;;AAED,aAAOsC,KAAP;AACD,K,CAED;AACA;;;;WACA,4BAAmBU,EAAnB,EAAuBC,EAAvB,EAA2B;AACzB,UAAIC,IAAI,GAAGD,EAAE,CAACX,KAAH,GAAWU,EAAE,CAACV,KAAzB;AACA,UAAIY,IAAJ,EAAU,OAAOA,IAAP;AACV,aAAO,KAAKhB,kBAAL,KAA4B,GAAnC;AACD;AAED;AACF;AACA;AACA;;;;WACE,gBAAOiB,gBAAP,EAAyB;AACvB,UAAI,KAAKA,gBAAL,KAA0BA,gBAA9B,EAAgD;AAC9C,aAAKzE,cAAL,GAAsB,EAAtB;AACD;;AACD,WAAKyE,gBAAL,GAAwBA,gBAAxB;AACA,WAAKC,yBAAL,GAAiC,KAAKD,gBAAL,CAAsBE,OAAtB,CAA8BC,aAA9B,CAC9BpD,MAD8B,CACvB,UAAAqD,CAAC;AAAA,eAAIA,CAAC,CAACC,IAAF,KAAW,YAAX,IAA2BD,CAAC,CAACC,IAAF,KAAW,cAA1C;AAAA,OADsB,EAE9B3D,GAF8B,CAE1BtB,GAAG,CAACkF,oBAFsB,CAAjC;AAGD;;;;2FAED,kBAA2BC,SAA3B,EAAsC9E,QAAtC;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,OAAO,KAAKuE,gBAAZ,KAAiC,WADvC;AAAA;AAAA;AAAA;;AAAA,sBAEU,IAAIQ,KAAJ,CAAU,4BAAV,CAFV;;AAAA;AAAA,sBAIM,KAAKjF,cAAL,CAAoBQ,MAApB,IAA8B,CAA9B,IAAmC,KAAKwE,SAAL,KAAmBA,SAJ5D;AAAA;AAAA;AAAA;;AAKI,qBAAKA,SAAL,GAAiBA,SAAjB;AALJ;AAAA,uBAMU,KAAKE,gBAAL,EANV;;AAAA;AAAA,kDAQS,KAAKC,uBAAL,CAA6B,KAAKnF,cAAlC,EAAkD,KAAKC,QAAvD,EAAiEC,QAAjE,EAA2E,KAAKC,OAAhF,CART;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAWA,iCAAwBH,cAAxB,EAAwCC,QAAxC,EAAkDC,QAAlD,EAA4DC,OAA5D,EAAqE;AACnE,aAAO,IAAIJ,iBAAJ,CAAsBC,cAAtB,EAAsCC,QAAtC,EAAgDC,QAAhD,EAA0DC,OAA1D,CAAP;AACD;AAED;AACF;AACA;AACA;;;;;uFACE;AAAA;AAAA;AAAA;AAAA;AAAA;AACMiF,gBAAAA,YADN,GACqB,EADrB;AAEMJ,gBAAAA,SAFN,GAEkB,KAAKA,SAAL,IAAkB,CAFpC;AAAA;AAAA,uBAGoC,KAAKP,gBAAL,CAAsBY,aAAtB,CAAoC,WAApC,EAAiD;AACjFL,kBAAAA,SAAS,EAAEA,SADsE;AAEjFM,kBAAAA,MAAM,EAAE,CAAC,KAAKZ,yBAAN;AAFyE,iBAAjD,CAHpC;;AAAA;AAGMa,gBAAAA,qBAHN;;AAQE,oBAAI,KAAKpF,OAAT,EAAkB;AAChBW,kBAAAA,OAAO,CAACC,GAAR,CAAY,6BAA6BwE,qBAAqB,CAAC/E,MAAnD,GAA4D,SAAxE;AACD,iBAVH,CAWE;AACA;;;AACA,qBAASgF,KAAT,IAAkBD,qBAAlB,EAAyC;AACnCE,kBAAAA,KADmC,GAC3BF,qBAAqB,CAACC,KAAD,CADM;;AAEvC,sBAAIC,KAAK,CAACA,KAAN,KAAgB,YAApB,EAAkC;AAC5BC,oBAAAA,IAD4B,GACrBD,KAAK,CAACE,YADe;AAE5BvE,oBAAAA,KAF4B,GAEpB;AACVwE,sBAAAA,OAAO,EAAEF,IAAI,CAACtE,KADJ;AAEVE,sBAAAA,QAAQ,EAAEoE,IAAI,CAACG,GAFL;AAGVtE,sBAAAA,cAAc,EAAEmE,IAAI,CAACnE,cAHX;AAIVwC,sBAAAA,KAAK,EAAE2B,IAAI,CAAC3B,KAJF;AAKVF,sBAAAA,YAAY,EAAE6B,IAAI,CAAC7B;AALT,qBAFoB;AAShCzC,oBAAAA,KAAK,CAACwC,KAAN,GAAc,KAAKN,mBAAL,CAAyBlC,KAAzB,CAAd;AACAgE,oBAAAA,YAAY,CAACM,IAAI,CAACtE,KAAN,CAAZ,GAA2BA,KAA3B;AACD,mBAXD,MAWO,IAAIqE,KAAK,CAACA,KAAN,KAAgB,cAApB,EAAoC;AACzC,2BAAOL,YAAY,CAACK,KAAK,CAACE,YAAN,CAAmBvE,KAApB,CAAnB;AACD;AACF;;AAEK0E,gBAAAA,UA/BR,GA+BqBzD,MAAM,CAAC0D,MAAP,CAAcX,YAAd,CA/BrB;;AAAA,sBAgCMU,UAAU,CAACtF,MAAX,KAAsB,CAhC5B;AAAA;AAAA;AAAA;;AAAA,sBAiCU,IAAIyE,KAAJ,0DAA4D,KAAKR,gBAAL,CAAsBE,OAAtB,CAA8BiB,OAA1F,EAjCV;;AAAA;AAoCQ5F,gBAAAA,cApCR,GAoCyB8F,UAAU,CAACtE,MAAX,CAAkB,KAAK+B,WAAvB,EAAoCyC,IAApC,CAAyC,KAAKC,kBAAL,CAAwBtC,IAAxB,CAA6B,IAA7B,CAAzC,CApCzB;;AAAA,sBAqCM3D,cAAc,CAACQ,MAAf,IAAyB,CArC/B;AAAA;AAAA;AAAA;;AAAA,sBAsCU,IAAIyE,KAAJ,CACJ,iEACEa,UAAU,CAAC3E,GAAX,CACE,UAAA+E,CAAC;AAAA,0CACWA,CAAC,CAACtC,KADb,oBAC4BsC,CAAC,CAAC3E,cAD9B,oBACsD2E,CAAC,CAACnC,KADxD,2BAC8EmC,CAAC,CAACrC,YADhF,sBACwGqC,CAAC,CAACN,OAD1G,kBACyHM,CAAC,CAAC5E,QAD3H;AAAA,iBADH,CAFE,CAtCV;;AAAA;AA+CE,oBAAI,KAAKnB,OAAT,EAAkB;AAChBW,kBAAAA,OAAO,CAACC,GAAR,CAAY,4CAA4Cf,cAAc,CAACQ,MAA3D,GAAoE,gBAAhF;AACD;;AAED,qBAAKR,cAAL,GAAsBA,cAAtB;AACA,qBAAKgE,aAAL,GAAqB,IAArB;AApDF,kDAqDShE,cArDT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AAyDFmG,MAAM,CAACC,OAAP,GAAiBnD,YAAjB","sourcesContent":["const BN = require('web3').utils.toBN;\nconst abi = require('web3-eth-abi');\n\n//relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\nconst DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nclass ActiveRelayPinger {\n  // TODO: 'httpSend' should be on a network layer\n  constructor(filteredRelays, httpSend, gasPrice, verbose) {\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n    this.errors = [];\n  }\n\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n  async nextRelay() {\n    if (this.remainingRelays.length === 0) {\n      return null;\n    }\n\n    let firstRelayToRespond;\n    for (; !firstRelayToRespond && this.remainingRelays.length; ) {\n      let bulkSize = Math.min(3, this.remainingRelays.length);\n      try {\n        let slice = this.remainingRelays.slice(0, bulkSize);\n        if (this.verbose) {\n          console.log('nextRelay: find fastest relay from: ' + JSON.stringify(slice));\n        }\n        firstRelayToRespond = await this.raceToSuccess(\n          slice.map(relay => this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, this.gasPrice)),\n        );\n        if (this.verbose) {\n          console.log('race finished with a champion: ' + firstRelayToRespond.relayUrl);\n        }\n      } catch (e) {\n        if (this.verbose) {\n          console.log('One batch of relays failed, last error: ', e);\n        }\n        //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n        this.remainingRelays = this.remainingRelays.slice(bulkSize);\n      }\n    }\n\n    this.remainingRelays = this.remainingRelays.filter(a => a.relayUrl !== firstRelayToRespond.relayUrl);\n    this.pingedRelays++;\n    return firstRelayToRespond;\n  }\n\n  /**\n   * @returns JSON response from the relay server, but adds the requested URL to it:\n   * { relayUrl: url,\n   *   transactionFee: fee,\n   *   RelayServerAddress: address,\n   *   Ready: bool,   //should ignore relays with \"false\"\n   *   MinGasPrice:   //minimum gas requirement by this relay.\n   * }\n   */\n  async getRelayAddressPing(relayUrl, transactionFee, gasPrice) {\n    let self = this;\n    return new Promise(function(resolve, reject) {\n      let callback = function(error, body) {\n        if (error) {\n          reject(`Error querying relayer ${relayUrl}: ${error.message || error.error || error.toString()}`);\n          return;\n        }\n        if (!body) {\n          reject(`Empty response from relayer ${relayUrl}`);\n          return;\n        }\n        if (!body.Ready) {\n          reject(`Relayer ${relayUrl} is not ready`);\n          return;\n        }\n        if (body.MinGasPrice > gasPrice) {\n          reject(\n            `Relayer ${relayUrl} requires a minimum gas price of ${body.MinGasPrice} which is over this transaction gas price (${gasPrice})`,\n          );\n          return;\n        }\n        try {\n          //add extra attributes (relayUrl, transactionFee)\n          Object.assign(body, { relayUrl, transactionFee });\n          resolve(body);\n        } catch (err) {\n          reject(err);\n        }\n      };\n      if (self.verbose) {\n        console.log('getRelayAddressPing URL: ' + relayUrl);\n      }\n      self.httpSend.send(relayUrl + '/getaddr', {}, callback);\n    });\n  }\n\n  /**\n   * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n   * Resolves once any promise resolves, ignores the rest, ignores rejections\n   */\n  async raceToSuccess(promises) {\n    let numRejected = 0;\n    return new Promise((resolve, reject) =>\n      promises.forEach(promise =>\n        promise\n          .then(res => {\n            resolve(res);\n          })\n          .catch(err => {\n            this.errors.push(err);\n            if (++numRejected === promises.length) {\n              reject('No response matched filter from any server: ' + err);\n            }\n          }),\n      ),\n    );\n  }\n}\n\nclass ServerHelper {\n  constructor(\n    httpSend,\n    failedRelays,\n    {\n      verbose,\n      minStake,\n      minDelay, //params for relayFilter: filter out this relay if unstakeDelay or stake are too low.\n      relayTimeoutGrace, //ignore score drop of a relay after this time (seconds)\n      calculateRelayScore, //function: return relay score, higher the better. default uses transactionFee and some randomness\n      relayFilter, //function: return false to filter out a relay. default uses minStake, minDelay\n      addScoreRandomness, //function: return Math.random (0..1), to fairly distribute among relays with same score.\n      // (used by test to REMOVE the randomness, and make the test deterministic.\n    },\n  ) {\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this);\n\n    //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n    this.relayFilter =\n      relayFilter ||\n      (relay =>\n        relay.score != null &&\n        (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) &&\n        (!minStake || BN(relay.stake).gte(BN(minStake))));\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  defaultCalculateRelayScore(relay) {\n    //basic score is trasnaction fee (which is %)\n    //higher the better.\n    let score = 1000 - relay.transactionFee;\n\n    let failedRelay = this.failedRelays[relay.relayUrl];\n    if (failedRelay) {\n      const elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n      if (elapsed < this.relayTimeoutGrace) score -= 10;\n      //relay failed to answer lately. demote.\n      else delete this.failedRelays[relay.relayUrl];\n    }\n\n    return score;\n  }\n\n  //compare relay scores.\n  // if they are the same, use addScoreRandomness to shuffle them..\n  compareRelayScores(r1, r2) {\n    let diff = r2.score - r1.score;\n    if (diff) return diff;\n    return this.addScoreRandomness() - 0.5;\n  }\n\n  /**\n   *\n   * @param {*} relayHubInstance\n   */\n  setHub(relayHubInstance) {\n    if (this.relayHubInstance !== relayHubInstance) {\n      this.filteredRelays = [];\n    }\n    this.relayHubInstance = relayHubInstance;\n    this.addedAndRemovedSignatures = this.relayHubInstance.options.jsonInterface\n      .filter(e => e.name === 'RelayAdded' || e.name === 'RelayRemoved')\n      .map(abi.encodeEventSignature);\n  }\n\n  async newActiveRelayPinger(fromBlock, gasPrice) {\n    if (typeof this.relayHubInstance === 'undefined') {\n      throw new Error('Must call to setHub first!');\n    }\n    if (this.filteredRelays.length == 0 || this.fromBlock !== fromBlock) {\n      this.fromBlock = fromBlock;\n      await this.fetchRelaysAdded();\n    }\n    return this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose);\n  }\n\n  createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n  }\n\n  /**\n   * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n   * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n   */\n  async fetchRelaysAdded() {\n    let activeRelays = {};\n    let fromBlock = this.fromBlock || 2;\n    let addedAndRemovedEvents = await this.relayHubInstance.getPastEvents('allEvents', {\n      fromBlock: fromBlock,\n      topics: [this.addedAndRemovedSignatures],\n    });\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: found ' + addedAndRemovedEvents.length + ' events');\n    }\n    //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n    //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n    for (var index in addedAndRemovedEvents) {\n      let event = addedAndRemovedEvents[index];\n      if (event.event === 'RelayAdded') {\n        let args = event.returnValues;\n        let relay = {\n          address: args.relay,\n          relayUrl: args.url,\n          transactionFee: args.transactionFee,\n          stake: args.stake,\n          unstakeDelay: args.unstakeDelay,\n        };\n        relay.score = this.calculateRelayScore(relay);\n        activeRelays[args.relay] = relay;\n      } else if (event.event === 'RelayRemoved') {\n        delete activeRelays[event.returnValues.relay];\n      }\n    }\n\n    const origRelays = Object.values(activeRelays);\n    if (origRelays.length === 0) {\n      throw new Error(`No relayers registered in the requested hub at ${this.relayHubInstance.options.address}`);\n    }\n\n    const filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n    if (filteredRelays.length == 0) {\n      throw new Error(\n        'No relayers elligible after filtering. Available relayers:\\n' +\n          origRelays.map(\n            r =>\n              ` score=${r.score} txFee=${r.transactionFee} stake=${r.stake} unstakeDelay=${r.unstakeDelay} address=${r.address} url=${r.relayUrl}`,\n          ),\n      );\n    }\n\n    if (this.verbose) {\n      console.log('fetchRelaysAdded: after filtering have ' + filteredRelays.length + ' active relays');\n    }\n\n    this.filteredRelays = filteredRelays;\n    this.isInitialized = true;\n    return filteredRelays;\n  }\n}\n\nmodule.exports = ServerHelper;\n"]},"metadata":{},"sourceType":"script"}