{"ast":null,"code":"import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher; // use compressed key because it's smaller\n\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'), // 16bit\n  Buffer.from(compressedKey, 'hex'), // 33bit\n  Buffer.from(cipher.mac, 'hex'), // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  }; // decompress publicKey\n\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","map":{"version":3,"sources":["/Users/john/Documents/GitHub/web3-3/node_modules/eth-crypto/dist/es/cipher.js"],"names":["compress","decompress","stringify","cipher","compressedKey","ephemPublicKey","ret","Buffer","concat","from","iv","mac","ciphertext","toString","parse","str","buf","length"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,UAAnB,QAAqC,cAArC;AAEA,OAAO,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AAC9B,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,OAAOA,MAAP,CADF,CAG9B;;AACA,MAAIC,aAAa,GAAGJ,QAAQ,CAACG,MAAM,CAACE,cAAR,CAA5B;AAEA,MAAIC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAc,CAACD,MAAM,CAACE,IAAP,CAAYN,MAAM,CAACO,EAAnB,EAAuB,KAAvB,CAAD,EAAgC;AACxDH,EAAAA,MAAM,CAACE,IAAP,CAAYL,aAAZ,EAA2B,KAA3B,CADwB,EACW;AACnCG,EAAAA,MAAM,CAACE,IAAP,CAAYN,MAAM,CAACQ,GAAnB,EAAwB,KAAxB,CAFwB,EAEQ;AAChCJ,EAAAA,MAAM,CAACE,IAAP,CAAYN,MAAM,CAACS,UAAnB,EAA+B,KAA/B,CAHwB,CAGc;AAHd,GAAd,CAAV;AAMA,SAAON,GAAG,CAACO,QAAJ,CAAa,KAAb,CAAP;AACH;AAED,OAAO,SAASC,KAAT,CAAeC,GAAf,EAAoB;AACvB,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,OAAOA,GAAP;AAE7B,MAAIC,GAAG,GAAGT,MAAM,CAACE,IAAP,CAAYM,GAAZ,EAAiB,KAAjB,CAAV;AAEA,MAAIT,GAAG,GAAG;AACNI,IAAAA,EAAE,EAAEM,GAAG,CAACH,QAAJ,CAAa,KAAb,EAAoB,CAApB,EAAuB,EAAvB,CADE;AAENR,IAAAA,cAAc,EAAEW,GAAG,CAACH,QAAJ,CAAa,KAAb,EAAoB,EAApB,EAAwB,EAAxB,CAFV;AAGNF,IAAAA,GAAG,EAAEK,GAAG,CAACH,QAAJ,CAAa,KAAb,EAAoB,EAApB,EAAwB,EAAxB,CAHC;AAIND,IAAAA,UAAU,EAAEI,GAAG,CAACH,QAAJ,CAAa,KAAb,EAAoB,EAApB,EAAwBG,GAAG,CAACC,MAA5B;AAJN,GAAV,CALuB,CAYvB;;AACAX,EAAAA,GAAG,CAACD,cAAJ,GAAqB,OAAOJ,UAAU,CAACK,GAAG,CAACD,cAAL,CAAtC;AAEA,SAAOC,GAAP;AACH","sourcesContent":["import { compress, decompress } from './public-key';\n\nexport function stringify(cipher) {\n    if (typeof cipher === 'string') return cipher;\n\n    // use compressed key because it's smaller\n    var compressedKey = compress(cipher.ephemPublicKey);\n\n    var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'), // 16bit\n    Buffer.from(compressedKey, 'hex'), // 33bit\n    Buffer.from(cipher.mac, 'hex'), // 32bit\n    Buffer.from(cipher.ciphertext, 'hex') // var bit\n    ]);\n\n    return ret.toString('hex');\n}\n\nexport function parse(str) {\n    if (typeof str !== 'string') return str;\n\n    var buf = Buffer.from(str, 'hex');\n\n    var ret = {\n        iv: buf.toString('hex', 0, 16),\n        ephemPublicKey: buf.toString('hex', 16, 49),\n        mac: buf.toString('hex', 49, 81),\n        ciphertext: buf.toString('hex', 81, buf.length)\n    };\n\n    // decompress publicKey\n    ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n\n    return ret;\n}"]},"metadata":{},"sourceType":"module"}