{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nconst web3_1 = __importDefault(require(\"web3\"));\n\nconst events_1 = require(\"events\");\n\nconst timeout_1 = __importDefault(require(\"../util/timeout\"));\n\nconst gsn_provider_1 = require(\"@openzeppelin/gsn-provider\");\n\nconst network_1 = __importDefault(require(\"../util/network\"));\n\nconst providerName_1 = __importDefault(require(\"../util/providerName\")); // TODO: Change event to use types using conditional types\n\n\nclass Web3Context extends events_1.EventEmitter {\n  constructor(provider, options) {\n    super();\n    this.connected = false;\n    this.accounts = [];\n    this.networkId = null;\n    this.networkName = null;\n    const fullOptions = Object.assign({}, {\n      timeout: 3000,\n      pollInterval: 500,\n      gsn: false\n    }, options);\n    if (!provider) throw new Error('A web3 provider has to be defined');\n\n    if (fullOptions.gsn) {\n      const gsnOptions = typeof fullOptions.gsn === 'object' ? fullOptions.gsn : {\n        useGSN: true\n      };\n      provider = !gsnOptions.dev ? new gsn_provider_1.GSNProvider(provider, gsnOptions) : new gsn_provider_1.GSNDevProvider(provider, gsnOptions);\n    }\n\n    this.providerName = providerName_1.default(provider);\n    this.lib = new web3_1.default(provider);\n    this.timeout = fullOptions.timeout;\n    this.pollInterval = fullOptions.pollInterval;\n  }\n\n  startPoll() {\n    if (!this.pollHandle) {\n      // TODO: polling interval should depend on kind of web3 provider\n      // We can query local providers often but doing the same for the network providers may create a lot of overhead\n      this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n    }\n  }\n\n  stopPoll() {\n    if (this.pollHandle) {\n      clearTimeout(this.pollHandle);\n      this.pollHandle = undefined;\n    }\n  }\n\n  async poll() {\n    // TODO: Fiture out elegant way retrive property name dynamically\n    const networkIdName = 'networkId';\n    const accountsName = 'accounts';\n    const connectedName = 'connected'; // getting deep here\n\n    const networkNameName = 'networkName';\n\n    try {\n      // get the current network ID\n      const newNetworkId = await timeout_1.default(this.lib.eth.net.getId(), this.timeout);\n      const newNetworkName = network_1.default(newNetworkId);\n      this.updateValueAndFireEvent(newNetworkName, networkNameName);\n      this.updateValueAndFireEvent(newNetworkId, networkIdName, Web3Context.NetworkIdChangedEventName, () => [newNetworkName]); // get the accounts\n\n      const newAccounts = await timeout_1.default(this.lib.eth.getAccounts(), this.timeout);\n      this.updateValueAndFireEvent(newAccounts, accountsName, Web3Context.AccountsChangedEventName); // if web3 provider calls are success then we are connected\n\n      this.updateValueAndFireEvent(true, connectedName, Web3Context.ConnectionChangedEventName);\n    } catch (e) {\n      // provider methods fail so we have to update the state and fire the events\n      this.updateValueAndFireEvent(false, connectedName, Web3Context.ConnectionChangedEventName);\n      this.updateValueAndFireEvent(null, networkIdName, Web3Context.NetworkIdChangedEventName, () => [null]);\n      this.updateValueAndFireEvent(null, networkNameName);\n      this.updateValueAndFireEvent(null, accountsName, Web3Context.AccountsChangedEventName); // TODO: Implement throtling so we do not spam console\n      // console.log(e);\n    } finally {\n      this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n    }\n  }\n\n  updateValueAndFireEvent(newValue, property, eventName, getArgs = () => []) {\n    if (!fast_deep_equal_1.default(newValue, this[property])) {\n      this[property] = newValue;\n      if (eventName) this.emit(eventName, this[property], ...getArgs());\n    }\n  } // request access according to the EIP\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n\n\n  async requestAuth() {\n    // Request authentication\n    if (this.lib.currentProvider.send !== undefined) {\n      return new Promise((resolve, reject) => {\n        const responseHandler = (error, response) => {\n          if (error || response.error) {\n            reject(error || response.error);\n          } else {\n            resolve(response.result);\n          }\n        };\n\n        const send = this.lib.currentProvider.send;\n        send({\n          method: 'eth_requestAccounts'\n        }, responseHandler);\n      });\n    } else return Promise.reject(new Error(\"Web3 provider doesn't support send method\"));\n  }\n\n}\n\nWeb3Context.NetworkIdChangedEventName = 'NetworkIdChanged';\nWeb3Context.AccountsChangedEventName = 'AccountsChanged';\nWeb3Context.ConnectionChangedEventName = 'ConnectionChanged';\nexports.default = Web3Context;","map":{"version":3,"sources":["../../src/context/Web3Context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst web3_1 = __importDefault(require(\"web3\"));\nconst events_1 = require(\"events\");\nconst timeout_1 = __importDefault(require(\"../util/timeout\"));\nconst gsn_provider_1 = require(\"@openzeppelin/gsn-provider\");\nconst network_1 = __importDefault(require(\"../util/network\"));\nconst providerName_1 = __importDefault(require(\"../util/providerName\"));\n// TODO: Change event to use types using conditional types\nclass Web3Context extends events_1.EventEmitter {\n    constructor(provider, options) {\n        super();\n        this.connected = false;\n        this.accounts = [];\n        this.networkId = null;\n        this.networkName = null;\n        const fullOptions = Object.assign({}, { timeout: 3000, pollInterval: 500, gsn: false }, options);\n        if (!provider)\n            throw new Error('A web3 provider has to be defined');\n        if (fullOptions.gsn) {\n            const gsnOptions = typeof fullOptions.gsn === 'object' ? fullOptions.gsn : { useGSN: true };\n            provider = !gsnOptions.dev ? new gsn_provider_1.GSNProvider(provider, gsnOptions) : new gsn_provider_1.GSNDevProvider(provider, gsnOptions);\n        }\n        this.providerName = providerName_1.default(provider);\n        this.lib = new web3_1.default(provider);\n        this.timeout = fullOptions.timeout;\n        this.pollInterval = fullOptions.pollInterval;\n    }\n    startPoll() {\n        if (!this.pollHandle) {\n            // TODO: polling interval should depend on kind of web3 provider\n            // We can query local providers often but doing the same for the network providers may create a lot of overhead\n            this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n        }\n    }\n    stopPoll() {\n        if (this.pollHandle) {\n            clearTimeout(this.pollHandle);\n            this.pollHandle = undefined;\n        }\n    }\n    async poll() {\n        // TODO: Fiture out elegant way retrive property name dynamically\n        const networkIdName = 'networkId';\n        const accountsName = 'accounts';\n        const connectedName = 'connected';\n        // getting deep here\n        const networkNameName = 'networkName';\n        try {\n            // get the current network ID\n            const newNetworkId = await timeout_1.default(this.lib.eth.net.getId(), this.timeout);\n            const newNetworkName = network_1.default(newNetworkId);\n            this.updateValueAndFireEvent(newNetworkName, networkNameName);\n            this.updateValueAndFireEvent(newNetworkId, networkIdName, Web3Context.NetworkIdChangedEventName, () => [newNetworkName]);\n            // get the accounts\n            const newAccounts = await timeout_1.default(this.lib.eth.getAccounts(), this.timeout);\n            this.updateValueAndFireEvent(newAccounts, accountsName, Web3Context.AccountsChangedEventName);\n            // if web3 provider calls are success then we are connected\n            this.updateValueAndFireEvent(true, connectedName, Web3Context.ConnectionChangedEventName);\n        }\n        catch (e) {\n            // provider methods fail so we have to update the state and fire the events\n            this.updateValueAndFireEvent(false, connectedName, Web3Context.ConnectionChangedEventName);\n            this.updateValueAndFireEvent(null, networkIdName, Web3Context.NetworkIdChangedEventName, () => [null]);\n            this.updateValueAndFireEvent(null, networkNameName);\n            this.updateValueAndFireEvent(null, accountsName, Web3Context.AccountsChangedEventName);\n            // TODO: Implement throtling so we do not spam console\n            // console.log(e);\n        }\n        finally {\n            this.pollHandle = setTimeout(this.poll.bind(this), this.pollInterval);\n        }\n    }\n    updateValueAndFireEvent(newValue, property, eventName, getArgs = () => []) {\n        if (!fast_deep_equal_1.default(newValue, this[property])) {\n            this[property] = newValue;\n            if (eventName)\n                this.emit(eventName, this[property], ...getArgs());\n        }\n    }\n    // request access according to the EIP\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    async requestAuth() {\n        // Request authentication\n        if (this.lib.currentProvider.send !== undefined) {\n            return new Promise((resolve, reject) => {\n                const responseHandler = (error, response) => {\n                    if (error || response.error) {\n                        reject(error || response.error);\n                    }\n                    else {\n                        resolve(response.result);\n                    }\n                };\n                const send = this.lib.currentProvider.send;\n                send({ method: 'eth_requestAccounts' }, responseHandler);\n            });\n        }\n        else\n            return Promise.reject(new Error(\"Web3 provider doesn't support send method\"));\n    }\n}\nWeb3Context.NetworkIdChangedEventName = 'NetworkIdChanged';\nWeb3Context.AccountsChangedEventName = 'AccountsChanged';\nWeb3Context.ConnectionChangedEventName = 'ConnectionChanged';\nexports.default = Web3Context;\n//# sourceMappingURL=Web3Context.js.map"]},"metadata":{},"sourceType":"script"}