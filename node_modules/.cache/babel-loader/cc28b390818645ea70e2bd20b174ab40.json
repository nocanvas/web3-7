{"ast":null,"code":"var _require = require(\"web3-utils\"),\n    sha3 = _require.sha3,\n    BN = _require.BN;\n\nvar abiCoder = require(\"web3-eth-abi\");\n\nvar state = {\n  savedABIs: [],\n  methodIDs: {},\n  keepNonDecodedLogs: false\n};\n\nfunction _getABIs() {\n  return state.savedABIs;\n}\n\nfunction _typeToString(input) {\n  if (input.type === \"tuple\") {\n    return \"(\" + input.components.map(_typeToString).join(\",\") + \")\";\n  }\n\n  return input.type;\n}\n\nfunction _addABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        var signature = sha3(abi.name + \"(\" + abi.inputs.map(_typeToString).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          state.methodIDs[signature.slice(2)] = abi;\n        } else {\n          state.methodIDs[signature.slice(2, 10)] = abi;\n        }\n      }\n    });\n    state.savedABIs = state.savedABIs.concat(abiArray);\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _removeABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        var signature = sha3(abi.name + \"(\" + abi.inputs.map(function (input) {\n          return input.type;\n        }).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          if (state.methodIDs[signature.slice(2)]) {\n            delete state.methodIDs[signature.slice(2)];\n          }\n        } else {\n          if (state.methodIDs[signature.slice(2, 10)]) {\n            delete state.methodIDs[signature.slice(2, 10)];\n          }\n        }\n      }\n    });\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _getMethodIDs() {\n  return state.methodIDs;\n}\n\nfunction _decodeMethod(data) {\n  var methodID = data.slice(2, 10);\n  var abiItem = state.methodIDs[methodID];\n\n  if (abiItem) {\n    var decoded = abiCoder.decodeParameters(abiItem.inputs, data.slice(10));\n    var retData = {\n      name: abiItem.name,\n      params: []\n    };\n\n    for (var i = 0; i < decoded.__length__; i++) {\n      var param = decoded[i];\n      var parsedParam = param;\n      var isUint = abiItem.inputs[i].type.indexOf(\"uint\") === 0;\n      var isInt = abiItem.inputs[i].type.indexOf(\"int\") === 0;\n      var isAddress = abiItem.inputs[i].type.indexOf(\"address\") === 0;\n\n      if (isUint || isInt) {\n        var isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(function (val) {\n            return new BN(val).toString();\n          });\n        } else {\n          parsedParam = new BN(param).toString();\n        }\n      } // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all\n\n\n      if (isAddress) {\n        var _isArray = Array.isArray(param);\n\n        if (_isArray) {\n          parsedParam = param.map(function (_) {\n            return _.toLowerCase();\n          });\n        } else {\n          parsedParam = param.toLowerCase();\n        }\n      }\n\n      retData.params.push({\n        name: abiItem.inputs[i].name,\n        value: parsedParam,\n        type: abiItem.inputs[i].type\n      });\n    }\n\n    return retData;\n  }\n}\n\nfunction _decodeLogs(logs) {\n  return logs.filter(function (log) {\n    return log.topics.length > 0;\n  }).map(function (logItem) {\n    var methodID = logItem.topics[0].slice(2);\n    var method = state.methodIDs[methodID];\n\n    if (method) {\n      var logData = logItem.data;\n      var decodedParams = [];\n      var dataIndex = 0;\n      var topicsIndex = 1;\n      var dataTypes = [];\n      method.inputs.map(function (input) {\n        if (!input.indexed) {\n          dataTypes.push(input.type);\n        }\n      });\n      var decodedData = abiCoder.decodeParameters(dataTypes, logData.slice(2)); // Loop topic and data to get the params\n\n      method.inputs.map(function (param) {\n        var decodedP = {\n          name: param.name,\n          type: param.type\n        };\n\n        if (param.indexed) {\n          decodedP.value = logItem.topics[topicsIndex];\n          topicsIndex++;\n        } else {\n          decodedP.value = decodedData[dataIndex];\n          dataIndex++;\n        }\n\n        if (param.type === \"address\") {\n          decodedP.value = decodedP.value.toLowerCase(); // 42 because len(0x) + 40\n\n          if (decodedP.value.length > 42) {\n            var toRemove = decodedP.value.length - 42;\n            var temp = decodedP.value.split(\"\");\n            temp.splice(2, toRemove);\n            decodedP.value = temp.join(\"\");\n          }\n        }\n\n        if (param.type === \"uint256\" || param.type === \"uint8\" || param.type === \"int\") {\n          // ensure to remove leading 0x for hex numbers\n          if (typeof decodedP.value === \"string\" && decodedP.value.startsWith(\"0x\")) {\n            decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);\n          } else {\n            decodedP.value = new BN(decodedP.value).toString(10);\n          }\n        }\n\n        decodedParams.push(decodedP);\n      });\n      return {\n        name: method.name,\n        events: decodedParams,\n        address: logItem.address\n      };\n    }\n  }).filter(function (decoded) {\n    return state.keepNonDecodedLogs || decoded;\n  });\n}\n\nfunction _keepNonDecodedLogs() {\n  state.keepNonDecodedLogs = true;\n}\n\nfunction _discardNonDecodedLogs() {\n  state.keepNonDecodedLogs = false;\n}\n\nmodule.exports = {\n  getABIs: _getABIs,\n  addABI: _addABI,\n  getMethodIDs: _getMethodIDs,\n  decodeMethod: _decodeMethod,\n  decodeLogs: _decodeLogs,\n  removeABI: _removeABI,\n  keepNonDecodedLogs: _keepNonDecodedLogs,\n  discardNonDecodedLogs: _discardNonDecodedLogs\n};","map":{"version":3,"sources":["/Users/john/Documents/GitHub/web3-3/node_modules/abi-decoder/index.js"],"names":["require","sha3","BN","abiCoder","state","savedABIs","methodIDs","keepNonDecodedLogs","_getABIs","_typeToString","input","type","components","map","join","_addABI","abiArray","Array","isArray","abi","name","signature","inputs","slice","concat","Error","_removeABI","_getMethodIDs","_decodeMethod","data","methodID","abiItem","decoded","decodeParameters","retData","params","i","__length__","param","parsedParam","isUint","indexOf","isInt","isAddress","val","toString","_","toLowerCase","push","value","_decodeLogs","logs","filter","log","topics","length","logItem","method","logData","decodedParams","dataIndex","topicsIndex","dataTypes","indexed","decodedData","decodedP","toRemove","temp","split","splice","startsWith","events","address","_keepNonDecodedLogs","_discardNonDecodedLogs","module","exports","getABIs","addABI","getMethodIDs","decodeMethod","decodeLogs","removeABI","discardNonDecodedLogs"],"mappings":"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","sourcesContent":["const { sha3, BN } = require(\"web3-utils\");\nconst abiCoder = require(\"web3-eth-abi\");\n\nconst state = {\n  savedABIs: [],\n  methodIDs: {},\n  keepNonDecodedLogs: false\n};\n\nfunction _getABIs() {\n  return state.savedABIs;\n}\n\nfunction _typeToString(input) {\n  if (input.type === \"tuple\") {\n    return \"(\" + input.components.map(_typeToString).join(\",\") + \")\";\n  }\n  return input.type;\n}\n\nfunction _addABI(abiArray) {\n\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function(abi) {\n      if (abi.name) {\n        const signature = sha3(\n          abi.name +\n            \"(\" +\n            abi.inputs\n              .map(_typeToString)\n              .join(\",\") +\n            \")\"\n        );\n        if (abi.type === \"event\") {\n          state.methodIDs[signature.slice(2)] = abi;\n        } else {\n          state.methodIDs[signature.slice(2, 10)] = abi;\n        }\n      }\n    });\n\n    state.savedABIs = state.savedABIs.concat(abiArray);\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _removeABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function(abi) {\n      if (abi.name) {\n        const signature = sha3(\n          abi.name +\n            \"(\" +\n            abi.inputs\n              .map(function(input) {\n                return input.type;\n              })\n              .join(\",\") +\n            \")\"\n        );\n        if (abi.type === \"event\") {\n          if (state.methodIDs[signature.slice(2)]) {\n            delete state.methodIDs[signature.slice(2)];\n          }\n        } else {\n          if (state.methodIDs[signature.slice(2, 10)]) {\n            delete state.methodIDs[signature.slice(2, 10)];\n          }\n        }\n      }\n    });\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _getMethodIDs() {\n  return state.methodIDs;\n}\n\nfunction _decodeMethod(data) {\n  const methodID = data.slice(2, 10);\n  const abiItem = state.methodIDs[methodID];\n  if (abiItem) {\n    let decoded = abiCoder.decodeParameters(abiItem.inputs, data.slice(10));\n\n    let retData = {\n      name: abiItem.name,\n      params: [],\n    };\n\n    for (let i = 0; i < decoded.__length__; i++) {\n      let param = decoded[i];\n      let parsedParam = param;\n      const isUint = abiItem.inputs[i].type.indexOf(\"uint\") === 0;\n      const isInt = abiItem.inputs[i].type.indexOf(\"int\") === 0;\n      const isAddress = abiItem.inputs[i].type.indexOf(\"address\") === 0;\n\n      if (isUint || isInt) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(val => new BN(val).toString());\n        } else {\n          parsedParam = new BN(param).toString();\n        }\n      }\n\n      // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all\n      if (isAddress) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(_ => _.toLowerCase());\n        } else {\n          parsedParam = param.toLowerCase();\n        }\n      }\n\n      retData.params.push({\n        name: abiItem.inputs[i].name,\n        value: parsedParam,\n        type: abiItem.inputs[i].type,\n      });\n    }\n\n    return retData;\n  }\n}\n\nfunction _decodeLogs(logs) {\n  return logs.filter(log => log.topics.length > 0).map((logItem) => {\n    const methodID = logItem.topics[0].slice(2);\n    const method = state.methodIDs[methodID];\n    if (method) {\n      const logData = logItem.data;\n      let decodedParams = [];\n      let dataIndex = 0;\n      let topicsIndex = 1;\n\n      let dataTypes = [];\n      method.inputs.map(function(input) {\n        if (!input.indexed) {\n          dataTypes.push(input.type);\n        }\n      });\n\n      const decodedData = abiCoder.decodeParameters(\n        dataTypes,\n        logData.slice(2)\n      );\n\n      // Loop topic and data to get the params\n      method.inputs.map(function(param) {\n        let decodedP = {\n          name: param.name,\n          type: param.type,\n        };\n\n        if (param.indexed) {\n          decodedP.value = logItem.topics[topicsIndex];\n          topicsIndex++;\n        } else {\n          decodedP.value = decodedData[dataIndex];\n          dataIndex++;\n        }\n\n        if (param.type === \"address\") {\n          decodedP.value = decodedP.value.toLowerCase();\n          // 42 because len(0x) + 40\n          if (decodedP.value.length > 42) {\n            let toRemove = decodedP.value.length - 42;\n            let temp = decodedP.value.split(\"\");\n            temp.splice(2, toRemove);\n            decodedP.value = temp.join(\"\");\n          }\n        }\n\n        if (\n          param.type === \"uint256\" ||\n          param.type === \"uint8\" ||\n          param.type === \"int\"\n        ) {\n          // ensure to remove leading 0x for hex numbers\n          if (typeof decodedP.value === \"string\" && decodedP.value.startsWith(\"0x\")) {\n            decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);\n          } else {\n            decodedP.value = new BN(decodedP.value).toString(10);\n          }\n\n        }\n\n        decodedParams.push(decodedP);\n      });\n\n      return {\n        name: method.name,\n        events: decodedParams,\n        address: logItem.address,\n      };\n    }\n  }).filter(decoded => state.keepNonDecodedLogs || decoded);\n}\n\nfunction _keepNonDecodedLogs(){\n  state.keepNonDecodedLogs = true\n}\n\nfunction _discardNonDecodedLogs(){\n  state.keepNonDecodedLogs = false\n}\n\nmodule.exports = {\n  getABIs: _getABIs,\n  addABI: _addABI,\n  getMethodIDs: _getMethodIDs,\n  decodeMethod: _decodeMethod,\n  decodeLogs: _decodeLogs,\n  removeABI: _removeABI,\n  keepNonDecodedLogs: _keepNonDecodedLogs,\n  discardNonDecodedLogs: _discardNonDecodedLogs\n};\n"]},"metadata":{},"sourceType":"script"}