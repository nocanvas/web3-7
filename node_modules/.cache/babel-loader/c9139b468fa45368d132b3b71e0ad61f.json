{"ast":null,"code":"const HubAbi = require('../tabookey-gasless/IRelayHub');\n\nconst RecipientAbi = require('../tabookey-gasless/IRelayRecipient');\n\nconst BN = require('bignumber.js');\n\nconst {\n  getApprovalData,\n  appendAddress,\n  preconditionCodeToDescription,\n  createRelayHubFromRecipient\n} = require('../utils');\n\nconst {\n  getTransactionHash,\n  getTransactionSignature\n} = require('../tabookey-gasless/utils');\n\nconst {\n  getCallDataGas\n} = require('../utils');\n\nconst TARGET_BALANCE = 2e18;\nconst MIN_BALANCE = 2e17;\nconst UNSTAKE_DELAY = 3600 * 24 * 7 * 4;\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst RELAY_STATE = Object.freeze({\n  Unknown: 0,\n  // The relay is unknown to the system: it has never been staked for\n  Staked: 1,\n  // The relay has been staked for, but it is not yet active\n  Registered: 2,\n  // The relay has registered itself, and is active (can relay calls)\n  Removed: 3 // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n\n});\n\nclass DevRelayClient {\n  constructor(web3, ownerAddress, relayerAddress, opts = {}) {\n    this.ownerAddress = ownerAddress;\n    this.relayerAddress = relayerAddress;\n    this.txFee = opts.txFee || 10;\n    this.web3 = web3;\n    this.approveFunction = opts.approveFunction;\n    this.options = opts;\n    this.debug = opts.debug;\n  }\n\n  async sendTransaction(payload) {\n    // Set accounts if not set in ctor\n    await this.ensureAccounts(); // Start by registering in the relayer hub\n\n    const txParams = payload.params[0];\n    const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n\n    if (!(await this.isRegistered(hub))) {\n      if (this.debug) console.log(`Relayer is not registered yet. Registering...`);\n      await this.register(hub);\n    } // Then sign the transaction as a regular provider would do\n\n\n    const nonce = parseInt(await hub.methods.getNonce(txParams.from).call());\n    const gasPrice = this.options.fixedGasPrice || txParams.gasPrice || (await this.web3.eth.getGasPrice());\n    const gas = this.options.fixedGasLimit || txParams.gas || (await this.estimateGas(txParams, hub.options.address));\n    await this.validateRecipientBalance(hub, txParams.to, gas, gasPrice);\n    if (this.debug) console.log(`Recipient has enough balance to pay for meta tx`);\n    const txHashToSign = getTransactionHash(txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, hub.options.address, this.relayerAddress);\n    const signature = await getTransactionSignature(this.web3, txParams.from, txHashToSign);\n    if (this.debug) console.log(`Got transaction hash ${txHashToSign} with signature ${signature}`);\n    const approvalData = await getApprovalData(txParams.approveFunction || this.approveFunction, {\n      from: txParams.from,\n      to: txParams.to,\n      encodedFunctionCall: txParams.data,\n      txFee: this.txFee,\n      gasPrice,\n      gas,\n      nonce,\n      relayerAddress: this.relayerAddress,\n      relayHubAddress: hub.options.address\n    });\n    if (this.approvalData !== '0x' && this.debug) console.log(`Approval data is ${approvalData}`); // Here the client would send the txParams, signature, and approvalData to the relayer\n    // Instead, we send it from the same process, posing as a relayer\n\n    await this.validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData);\n    if (this.debug) console.log(`Can relay check succeeded`);\n    const requiredGas = BN(await hub.methods.requiredGas(gas.toString()).call()).plus(getCallDataGas(txParams.data)).toString();\n    if (this.debug) console.log(`Relaying transaction with gas ${requiredGas}`);\n    return new Promise((resolve, reject) => {\n      hub.methods.relayCall(txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, signature, approvalData).send({\n        from: this.relayerAddress,\n        gasPrice,\n        gas: requiredGas\n      }).on('transactionHash', txHash => {\n        resolve(txHash);\n      }).on('error', err => {\n        reject(err);\n      });\n    });\n  }\n\n  async validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData) {\n    let status, recipientContext;\n\n    try {\n      ({\n        status,\n        recipientContext\n      } = await hub.methods.canRelay(this.relayerAddress, txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, signature, approvalData).call({\n        from: this.relayerAddress\n      }));\n    } catch (err) {\n      throw new Error(`Error checking canRelay for transaction: ${err.message || err}`);\n    }\n\n    if (parseInt(status) !== 0) {\n      throw new Error(`Recipient canRelay call was rejected with ${preconditionCodeToDescription(status)}`);\n    }\n\n    return recipientContext;\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n\n    const txParamsFromHub = { ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from)\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n\n  async validateRecipientBalance(hub, recipient, gasLimit, gasPrice) {\n    const relayFee = this.txFee;\n    const balance = await hub.methods.balanceOf(recipient).call();\n\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await hub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(`Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`);\n    }\n  }\n\n  async register(hub) {\n    await this.ensureAccounts();\n    await this.ensureStake(hub);\n    await hub.methods.registerRelay(this.txFee.toString(), 'http://gsn-dev-relayer.openzeppelin.com/').send({\n      from: this.relayerAddress\n    });\n    if (this.debug) console.log(`Registered relayer with address ${this.relayerAddress}`);\n  }\n\n  async ensureStake(hub, targetBalance = TARGET_BALANCE, minBalance = MIN_BALANCE) {\n    await this.ensureAccounts();\n    const currentStake = await this.getCurrentStake(hub);\n    const target = new BN(targetBalance);\n    const min = new BN(minBalance);\n\n    if (currentStake.gte(min)) {\n      if (this.debug) console.log(`Current stake ${currentStake.toString()} is over minimum stake ${min.toString()}`);\n      return;\n    }\n\n    if (this.debug) console.log(`Staking to reach ${targetBalance.toString()}`);\n    await hub.methods.stake(this.relayerAddress, UNSTAKE_DELAY.toString()).send({\n      from: this.ownerAddress,\n      value: target.minus(currentStake).toString()\n    });\n  }\n\n  async getCurrentStake(hub) {\n    await this.ensureAccounts();\n    let currentStake;\n\n    try {\n      currentStake = (await hub.methods.getRelay(this.relayerAddress).call()).totalStake;\n    } catch (err) {\n      console.error(`Error getting current relayer stake ${err.message}`);\n      currentStake = 0;\n    }\n\n    return new BN(currentStake);\n  }\n\n  async isRegistered(hub) {\n    let currentState;\n\n    try {\n      currentState = (await hub.methods.getRelay(this.relayerAddress).call()).state;\n    } catch (err) {\n      console.error(`Error getting current relayer state ${err.message}`);\n      currentState = 0;\n    }\n\n    return Number(currentState) === RELAY_STATE.Registered;\n  }\n\n  async ensureAccounts() {\n    if (this.ownerAddress && this.relayerAddress) return; // If the current provider is a PrivateKey one, then eth.getAccounts will return the account\n    // that corresponds to signKey. We need to bypass it to get the actual accounts found on the node.\n\n    const web3 = this.web3.currentProvider.isPrivateKeyProvider ? new this.web3.constructor(this.web3.currentProvider.baseProvider) : this.web3; // Get all accounts and take the first two to use as relayer and owner\n\n    let accounts;\n\n    try {\n      accounts = await web3.eth.getAccounts();\n    } catch (err) {\n      throw new Error(`Error getting accounts from local node for GSNDevProvider (${err.message}). Please set them manually using the ownerAddress and relayerAddress options.`);\n    }\n\n    if (accounts.length < 2) {\n      throw new Error(`Error setting up owner and relayer accounts for GSNDevProvider (at least two unlocked accounts are needed on the local node but found ${accounts.length}). Please set them manually using the ownerAddress and relayerAddress options.`);\n    }\n\n    this.ownerAddress = this.ownerAddress || accounts[0];\n    this.relayerAddress = this.relayerAddress || accounts[1];\n  }\n\n}\n\nmodule.exports = DevRelayClient;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/test1/node_modules/@openzeppelin/gsn-provider/src/dev/DevRelayClient.js"],"names":["HubAbi","require","RecipientAbi","BN","getApprovalData","appendAddress","preconditionCodeToDescription","createRelayHubFromRecipient","getTransactionHash","getTransactionSignature","getCallDataGas","TARGET_BALANCE","MIN_BALANCE","UNSTAKE_DELAY","ZERO_ADDRESS","RELAY_STATE","Object","freeze","Unknown","Staked","Registered","Removed","DevRelayClient","constructor","web3","ownerAddress","relayerAddress","opts","txFee","approveFunction","options","debug","sendTransaction","payload","ensureAccounts","txParams","params","hub","to","isRegistered","console","log","register","nonce","parseInt","methods","getNonce","from","call","gasPrice","fixedGasPrice","eth","getGasPrice","gas","fixedGasLimit","estimateGas","address","validateRecipientBalance","txHashToSign","data","signature","approvalData","encodedFunctionCall","relayHubAddress","validateCanRelay","requiredGas","toString","plus","Promise","resolve","reject","relayCall","send","on","txHash","err","status","recipientContext","canRelay","Error","message","hubAddress","txParamsFromHub","recipient","gasLimit","relayFee","balance","balanceOf","isZero","maxCharge","maxPossibleCharge","isGreaterThan","ensureStake","registerRelay","targetBalance","minBalance","currentStake","getCurrentStake","target","min","gte","stake","value","minus","getRelay","totalStake","error","currentState","state","Number","currentProvider","isPrivateKeyProvider","baseProvider","accounts","getAccounts","length","module","exports"],"mappings":"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","sourcesContent":["const HubAbi = require('../tabookey-gasless/IRelayHub');\nconst RecipientAbi = require('../tabookey-gasless/IRelayRecipient');\nconst BN = require('bignumber.js');\nconst {\n  getApprovalData,\n  appendAddress,\n  preconditionCodeToDescription,\n  createRelayHubFromRecipient,\n} = require('../utils');\nconst { getTransactionHash, getTransactionSignature } = require('../tabookey-gasless/utils');\nconst { getCallDataGas } = require('../utils');\n\nconst TARGET_BALANCE = 2e18;\nconst MIN_BALANCE = 2e17;\nconst UNSTAKE_DELAY = 3600 * 24 * 7 * 4;\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst RELAY_STATE = Object.freeze({\n  Unknown: 0, // The relay is unknown to the system: it has never been staked for\n  Staked: 1, // The relay has been staked for, but it is not yet active\n  Registered: 2, // The relay has registered itself, and is active (can relay calls)\n  Removed: 3    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n})\n\nclass DevRelayClient {\n  constructor(web3, ownerAddress, relayerAddress, opts = {}) {\n    this.ownerAddress = ownerAddress;\n    this.relayerAddress = relayerAddress;\n    this.txFee = opts.txFee || 10;\n    this.web3 = web3;\n    this.approveFunction = opts.approveFunction;\n    this.options = opts;\n    this.debug = opts.debug;\n  }\n\n  async sendTransaction(payload) {\n    // Set accounts if not set in ctor\n    await this.ensureAccounts();\n\n    // Start by registering in the relayer hub\n    const txParams = payload.params[0];\n    const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n    if(!(await this.isRegistered(hub))) {\n      if (this.debug) console.log(`Relayer is not registered yet. Registering...`);\n      await this.register(hub);\n    }\n\n    // Then sign the transaction as a regular provider would do\n    const nonce = parseInt(await hub.methods.getNonce(txParams.from).call());\n    const gasPrice = this.options.fixedGasPrice || txParams.gasPrice || (await this.web3.eth.getGasPrice());\n    const gas = this.options.fixedGasLimit || txParams.gas || (await this.estimateGas(txParams, hub.options.address));\n\n    await this.validateRecipientBalance(hub, txParams.to, gas, gasPrice);\n    if (this.debug) console.log(`Recipient has enough balance to pay for meta tx`);\n\n    const txHashToSign = getTransactionHash(\n      txParams.from,\n      txParams.to,\n      txParams.data,\n      this.txFee,\n      gasPrice,\n      gas,\n      nonce,\n      hub.options.address,\n      this.relayerAddress,\n    );\n\n    const signature = await getTransactionSignature(this.web3, txParams.from, txHashToSign);\n    if (this.debug) console.log(`Got transaction hash ${txHashToSign} with signature ${signature}`);\n\n    const approvalData = await getApprovalData(txParams.approveFunction || this.approveFunction, {\n      from: txParams.from,\n      to: txParams.to,\n      encodedFunctionCall: txParams.data,\n      txFee: this.txFee,\n      gasPrice,\n      gas,\n      nonce,\n      relayerAddress: this.relayerAddress,\n      relayHubAddress: hub.options.address,\n    });\n    if (this.approvalData !== '0x' && this.debug) console.log(`Approval data is ${approvalData}`);\n\n    // Here the client would send the txParams, signature, and approvalData to the relayer\n    // Instead, we send it from the same process, posing as a relayer\n    await this.validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData);\n    if (this.debug) console.log(`Can relay check succeeded`);\n\n    const requiredGas = BN(await hub.methods.requiredGas(gas.toString()).call())\n      .plus(getCallDataGas(txParams.data))\n      .toString();\n    if (this.debug) console.log(`Relaying transaction with gas ${requiredGas}`);\n\n    return new Promise((resolve, reject) => {\n      hub.methods\n        .relayCall(txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, signature, approvalData)\n        .send({ from: this.relayerAddress, gasPrice, gas: requiredGas })\n        .on('transactionHash', txHash => {\n          resolve(txHash);\n        })\n        .on('error', err => {\n          reject(err);\n        });\n    });\n  }\n\n  async validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData) {\n    let status, recipientContext;\n    try {\n      ({ status, recipientContext } = await hub.methods\n        .canRelay(\n          this.relayerAddress,\n          txParams.from,\n          txParams.to,\n          txParams.data,\n          this.txFee,\n          gasPrice,\n          gas,\n          nonce,\n          signature,\n          approvalData,\n        )\n        .call({ from: this.relayerAddress }));\n    } catch (err) {\n      throw new Error(`Error checking canRelay for transaction: ${err.message || err}`);\n    }\n    if (parseInt(status) !== 0) {\n      throw new Error(`Recipient canRelay call was rejected with ${preconditionCodeToDescription(status)}`);\n    }\n    return recipientContext;\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n    const txParamsFromHub = {\n      ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from),\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n\n  async validateRecipientBalance(hub, recipient, gasLimit, gasPrice) {\n    const relayFee = this.txFee;\n    const balance = await hub.methods.balanceOf(recipient).call();\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await hub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(\n        `Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`,\n      );\n    }\n  }\n\n  async register(hub) {\n    await this.ensureAccounts();\n    await this.ensureStake(hub);\n    await hub.methods\n      .registerRelay(this.txFee.toString(), 'http://gsn-dev-relayer.openzeppelin.com/')\n      .send({ from: this.relayerAddress });\n    if (this.debug) console.log(`Registered relayer with address ${this.relayerAddress}`);\n  }\n\n  async ensureStake(hub, targetBalance = TARGET_BALANCE, minBalance = MIN_BALANCE) {\n    await this.ensureAccounts();\n    const currentStake = await this.getCurrentStake(hub);\n    const target = new BN(targetBalance);\n    const min = new BN(minBalance);\n\n    if (currentStake.gte(min)) {\n      if (this.debug) console.log(`Current stake ${currentStake.toString()} is over minimum stake ${min.toString()}`);\n      return;\n    }\n\n    if (this.debug) console.log(`Staking to reach ${targetBalance.toString()}`);\n    await hub.methods\n      .stake(this.relayerAddress, UNSTAKE_DELAY.toString())\n      .send({ from: this.ownerAddress, value: target.minus(currentStake).toString() });\n  }\n\n  async getCurrentStake(hub) {\n    await this.ensureAccounts();\n    let currentStake;\n    try {\n      currentStake = (await hub.methods.getRelay(this.relayerAddress).call()).totalStake;\n    } catch (err) {\n      console.error(`Error getting current relayer stake ${err.message}`)\n      currentStake = 0;\n    }\n    return new BN(currentStake);\n  }\n\n  async isRegistered(hub) {\n    let currentState;\n    try {\n      currentState = (await hub.methods.getRelay(this.relayerAddress).call()).state;\n    } catch (err) {\n      console.error(`Error getting current relayer state ${err.message}`)\n      currentState = 0;\n    }\n    return Number(currentState) === RELAY_STATE.Registered;\n  }\n\n  async ensureAccounts() {\n    if (this.ownerAddress && this.relayerAddress) return;\n\n    // If the current provider is a PrivateKey one, then eth.getAccounts will return the account\n    // that corresponds to signKey. We need to bypass it to get the actual accounts found on the node.\n    const web3 = this.web3.currentProvider.isPrivateKeyProvider\n      ? new this.web3.constructor(this.web3.currentProvider.baseProvider)\n      : this.web3;\n\n    // Get all accounts and take the first two to use as relayer and owner\n    let accounts;\n    try {\n      accounts = await web3.eth.getAccounts();\n    } catch (err) {\n      throw new Error(\n        `Error getting accounts from local node for GSNDevProvider (${err.message}). Please set them manually using the ownerAddress and relayerAddress options.`,\n      );\n    }\n\n    if (accounts.length < 2) {\n      throw new Error(\n        `Error setting up owner and relayer accounts for GSNDevProvider (at least two unlocked accounts are needed on the local node but found ${accounts.length}). Please set them manually using the ownerAddress and relayerAddress options.`,\n      );\n    }\n    this.ownerAddress = this.ownerAddress || accounts[0];\n    this.relayerAddress = this.relayerAddress || accounts[1];\n  }\n}\n\nmodule.exports = DevRelayClient;\n"]},"metadata":{},"sourceType":"script"}