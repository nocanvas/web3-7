{"ast":null,"code":"var _objectSpread = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/test1/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar utils = require('./utils');\n\nvar getTransactionSignature = utils.getTransactionSignature;\nvar getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nvar parseHexString = utils.parseHexString;\nvar removeHexPrefix = utils.removeHexPrefix;\nvar padTo64 = utils.padTo64;\n\nvar ServerHelper = require('./ServerHelper');\n\nvar HttpWrapper = require('./HttpWrapper');\n\nvar ethUtils = require('ethereumjs-util');\n\nvar ethWallet = require('ethereumjs-wallet');\n\nvar ethJsTx = require('ethereumjs-tx');\n\nvar abi_decoder = require('abi-decoder');\n\nvar BN = require('bignumber.js');\n\nvar _require = require('../utils'),\n    appendAddress = _require.appendAddress,\n    toInt = _require.toInt,\n    preconditionCodeToDescription = _require.preconditionCodeToDescription,\n    getApprovalData = _require.getApprovalData,\n    createRelayHubFromRecipient = _require.createRelayHubFromRecipient;\n\nvar relayHubAbi = require('./IRelayHub');\n\nvar relayRecipientAbi = require('./IRelayRecipient');\n\nvar relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi); // default timeout (in ms) for http requests\n\nvar DEFAULT_HTTP_TIMEOUT = 10000; //default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\n\nvar GASPRICE_PERCENT = 20;\n\nvar RelayClient = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    preferredRelayer - skip relayer lookup and use this preferred relayer, fallbacking to regular lookup on error\n   *       An example preferredRelayer configuration:\n   *        {\n   *          RelayServerAddress: '0x73a652f54d5fd8273f17a28e206d47f5bd1bc06a',\n   *          relayUrl: 'http://localhost:8090',\n   *          transactionFee: '70'\n   *        }\n   *       These values can be be retrieved from the `/getaddr` endpoint of a relayer. e.g `curl http://localhost:8090/getaddr`\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  function RelayClient(web3, config) {\n    _classCallCheck(this, RelayClient);\n\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign({\n      httpTimeout: DEFAULT_HTTP_TIMEOUT\n    }, config);\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({\n      timeout: this.config.httpTimeout\n    });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  _createClass(RelayClient, [{\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(payload) {\n        var relayOptions, tx;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                relayOptions = this.getTransactionOptions(payload);\n                _context.next = 3;\n                return this.relayTransaction(payload.params[0].data, relayOptions);\n\n              case 3:\n                tx = _context.sent;\n                return _context.abrupt(\"return\", ethUtils.bufferToHex(tx.hash(true)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendTransaction(_x) {\n        return _sendTransaction.apply(this, arguments);\n      }\n\n      return sendTransaction;\n    }()\n  }, {\n    key: \"getTransactionOptions\",\n    value: function getTransactionOptions(payload) {\n      var params = payload.params[0];\n      var relayClientOptions = this.config;\n      var relayOptions = {\n        from: params.from,\n        to: params.to,\n        txfee: params.txFee || params.txfee || relayClientOptions.txFee || relayClientOptions.txfee,\n        gas_limit: params.gas && toInt(params.gas),\n        gas_price: params.gasPrice && toInt(params.gasPrice),\n        approveFunction: params.approveFunction || this.config.approveFunction\n      };\n      if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n      return relayOptions;\n    }\n    /**\n     * Decode the signed transaction returned from the Relay Server, compare it to the\n     * requested transaction and validate its signature.\n     * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n     * transaction is not valid.\n     */\n\n  }, {\n    key: \"validateRelayResponse\",\n    value: function validateRelayResponse(returned_tx, address_relay, from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address, sig, approvalData) {\n      var tx = new ethJsTx({\n        nonce: returned_tx.nonce,\n        gasPrice: returned_tx.gasPrice,\n        gasLimit: returned_tx.gas,\n        to: returned_tx.to,\n        value: returned_tx.value,\n        data: returned_tx.input\n      });\n      var message = tx.hash(false);\n      var tx_v = Buffer.from(removeHexPrefix(returned_tx.v), 'hex');\n      var tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), 'hex');\n      var tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), 'hex');\n      var signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n      var request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n      var returned_tx_params_hash = utils.getTransactionHash(request_decoded_params[0].value, request_decoded_params[1].value, request_decoded_params[2].value, request_decoded_params[3].value, request_decoded_params[4].value, request_decoded_params[5].value, request_decoded_params[6].value, returned_tx.to, signer);\n      var transaction_orig_params_hash = utils.getTransactionHash(from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address);\n\n      if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n        if (this.config.verbose) {\n          console.log('validateRelayResponse - valid transaction response');\n        }\n\n        tx.v = tx_v;\n        tx.r = tx_r;\n        tx.s = tx_s;\n        return tx;\n      } else {\n        console.error('validateRelayResponse: req', JSON.stringify(request_decoded_params));\n        console.error('validateRelayResponse: rsp', {\n          returned_tx: returned_tx,\n          address_relay: address_relay,\n          from: from,\n          to: to,\n          transaction_orig: transaction_orig,\n          transaction_fee: transaction_fee,\n          gas_price: gas_price,\n          gas_limit: gas_limit,\n          nonce: nonce,\n          sig: sig,\n          approvalData: approvalData,\n          signer: signer\n        });\n      }\n    }\n    /**\n     * Performs a '/relay' HTTP request to the given url\n     * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n     */\n\n  }, {\n    key: \"sendViaRelay\",\n    value: function sendViaRelay(relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, signature, approvalData, relayUrl, relayHubAddress, relayMaxNonce) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var jsonRequestData = {\n          encodedFunction: encodedFunction,\n          signature: parseHexString(signature.replace(/^0x/, '')),\n          approvalData: parseHexString(approvalData.replace(/^0x/, '')),\n          from: from,\n          to: to,\n          gasPrice: gasprice,\n          gasLimit: gaslimit,\n          relayFee: relayFee,\n          RecipientNonce: parseInt(recipientNonce),\n          RelayMaxNonce: parseInt(relayMaxNonce),\n          RelayHubAddress: relayHubAddress\n        };\n\n        var callback = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(error, body) {\n            var validTransaction, receivedNonce, raw_tx, txHash;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!error) {\n                      _context2.next = 4;\n                      break;\n                    }\n\n                    if (error.error && error.error.indexOf('timeout') != -1) {\n                      self.failedRelays[relayUrl] = {\n                        lastError: new Date().getTime(),\n                        address: relayAddress,\n                        url: relayUrl\n                      };\n                    }\n\n                    reject(error);\n                    return _context2.abrupt(\"return\");\n\n                  case 4:\n                    if (self.config.verbose) {\n                      console.log('sendViaRelay resp=', body);\n                    }\n\n                    if (!(body && body.error)) {\n                      _context2.next = 8;\n                      break;\n                    }\n\n                    reject(body.error);\n                    return _context2.abrupt(\"return\");\n\n                  case 8:\n                    if (!(!body || !body.nonce)) {\n                      _context2.next = 11;\n                      break;\n                    }\n\n                    reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n                    return _context2.abrupt(\"return\");\n\n                  case 11:\n                    try {\n                      validTransaction = self.validateRelayResponse(body, relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, relayHubAddress, relayAddress, signature, approvalData);\n                    } catch (error) {\n                      console.error('validateRelayResponse ' + error);\n                    }\n\n                    if (validTransaction) {\n                      _context2.next = 15;\n                      break;\n                    }\n\n                    reject('Failed to validate response');\n                    return _context2.abrupt(\"return\");\n\n                  case 15:\n                    receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n\n                    if (!(receivedNonce > relayMaxNonce)) {\n                      _context2.next = 19;\n                      break;\n                    }\n\n                    // TODO: need to validate that client retries the same request and doesn't double-spend.\n                    // Note that this transaction is totally valid from the EVM's point of view\n                    reject('Relay used a tx nonce higher than requested. Requested ' + relayMaxNonce + ' got ' + receivedNonce);\n                    return _context2.abrupt(\"return\");\n\n                  case 19:\n                    raw_tx = '0x' + validTransaction.serialize().toString('hex');\n                    txHash = '0x' + validTransaction.hash(true).toString('hex');\n                    if (self.config.verbose) console.log('txHash= ' + txHash);\n                    self.broadcastRawTx(raw_tx, txHash);\n                    resolve(validTransaction);\n\n                  case 24:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function callback(_x2, _x3) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        if (self.config.verbose) {\n          var replacer = function replacer(key, value) {\n            if (key === 'signature') return signature;else return value;\n          };\n\n          console.log('sendViaRelay to URL: ' + relayUrl + ' ' + JSON.stringify(jsonRequestData, replacer));\n        }\n\n        self.httpSend.send(relayUrl + '/relay', _objectSpread(_objectSpread({}, jsonRequestData), {}, {\n          userAgent: self.config.userAgent\n        }), callback);\n      });\n    }\n    /**\n     * In case Relay Server does not broadcast the signed transaction to the network,\n     * client also broadcasts the same transaction. If the transaction fails with nonce\n     * error, it indicates Relay may have signed multiple transactions with same nonce,\n     * causing a DoS attack.\n     *\n     * @param {*} raw_tx - raw transaction bytes, signed by relay\n     * @param {*} tx_hash - this transaction's ID\n     */\n\n  }, {\n    key: \"broadcastRawTx\",\n    value: function broadcastRawTx(raw_tx, tx_hash) {\n      var self = this;\n      self.web3.eth.sendSignedTransaction(raw_tx, function (error, result) {\n        //TODO: at this point both client and relay has sent the transaction to the blockchain.\n        // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n        // to penalize original relay for cheating: returning one transaction to the client, and\n        // broadcasting another with the same nonce.\n        // see the EIP for description of the attack\n        //don't display error for the known-good cases\n        if (!('' + error).match(/the tx doesn't have the correct nonce|known transaction/)) {\n          if (self.config.verbose) {\n            // TODO: Should we actually bubble up an error?\n            console.log('broadcastTx: ', error || result);\n          }\n        }\n\n        if (error) {//note that nonce-related errors at this point are VALID reponses: it means that\n          // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n          // the only point is that different node versions return different error strings:\n          // ganache:  \"the tx doesn't have the correct nonce\"\n          // ropsten: \"known transaction\"\n        } else {\n          if (result == tx_hash) {//transaction already on chain\n          }\n        }\n      });\n    }\n    /**\n     * check the balance of the given target contract.\n     * the method will fail if the target is not a RelayRecipient.\n     * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n     */\n\n  }, {\n    key: \"balanceOf\",\n    value: function () {\n      var _balanceOf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(target) {\n        var relayHub;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return createRelayHubFromRecipient(this.web3, target);\n\n              case 2:\n                relayHub = _context3.sent;\n                return _context3.abrupt(\"return\", relayHub.methods.balanceOf(target).call());\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function balanceOf(_x4) {\n        return _balanceOf.apply(this, arguments);\n      }\n\n      return balanceOf;\n    }()\n    /**\n     * Options include standard transaction params: from,to, gasprice, gaslimit\n     * can also override default relayUrl, relayFee\n     * return value is the same as from sendTransaction\n     */\n\n  }, {\n    key: \"relayTransaction\",\n    value: function () {\n      var _relayTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(encodedFunctionCall, options) {\n        var self, relayHub, nonce, pct, network_gas_price, gasPrice, gasLimit, blockNow, blockFrom, pinger, errors, activeRelay, nextRelay, subErrors, error, relayAddress, relayUrl, txfee, hash, signature, approvalData, rec, allowed_relay_nonce_gap, relayMaxNonce, validTransaction, errMsg;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                self = this;\n                _context4.next = 3;\n                return createRelayHubFromRecipient(this.web3, options.to);\n\n              case 3:\n                relayHub = _context4.sent;\n                _context4.t0 = parseInt;\n                _context4.next = 7;\n                return relayHub.methods.getNonce(options.from).call();\n\n              case 7:\n                _context4.t1 = _context4.sent;\n                nonce = (0, _context4.t0)(_context4.t1);\n                this.serverHelper.setHub(relayHub); //gas-price multiplicator: either default (10%) or configuration factor\n\n                pct = this.config.gasPriceFactorPercent || this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n                _context4.next = 13;\n                return this.web3.eth.getGasPrice();\n\n              case 13:\n                network_gas_price = _context4.sent;\n\n                // Sometimes, xDai netwiork returns '0'\n                if (!network_gas_price || network_gas_price == 0) {\n                  network_gas_price = 1e9;\n                }\n\n                gasPrice = this.config.fixedGasPrice || //forced gasprice\n                this.config.force_gasPrice || options.gas_price || //user-supplied gas price\n                Math.round(network_gas_price * (pct + 100) / 100); //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n\n                gasLimit = this.config.fixedGasLimit || this.config.force_gasLimit || options.gas_limit; // If we don't have a gas limit, then estimate it, since we need a concrete value for checking the recipient balance\n\n                _context4.prev = 17;\n\n                if (gasLimit) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                _context4.next = 21;\n                return this.estimateGas({\n                  to: options.to,\n                  from: options.from,\n                  gasPrice: gasPrice,\n                  data: encodedFunctionCall\n                }, relayHub.options.address);\n\n              case 21:\n                gasLimit = _context4.sent;\n\n              case 22:\n                _context4.next = 27;\n                break;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.t2 = _context4[\"catch\"](17);\n                throw new Error(\"Error estimating gas usage for transaction (\".concat(_context4.t2.message, \"). Make sure the transaction is valid, or set a fixed gas value.\"));\n\n              case 27:\n                _context4.next = 29;\n                return this.validateRecipientBalance(relayHub, options.to, gasLimit, gasPrice, 0);\n\n              case 29:\n                _context4.next = 31;\n                return this.web3.eth.getBlockNumber();\n\n              case 31:\n                blockNow = _context4.sent;\n                blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n                _context4.next = 35;\n                return this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n\n              case 35:\n                pinger = _context4.sent;\n                errors = [];\n\n              case 37:\n                if (!(activeRelay === undefined && self.config.preferredRelayer !== undefined)) {\n                  _context4.next = 41;\n                  break;\n                }\n\n                activeRelay = self.config.preferredRelayer;\n                _context4.next = 52;\n                break;\n\n              case 41:\n                _context4.next = 43;\n                return pinger.nextRelay();\n\n              case 43:\n                nextRelay = _context4.sent;\n\n                if (!nextRelay) {\n                  _context4.next = 48;\n                  break;\n                }\n\n                activeRelay = nextRelay;\n                _context4.next = 52;\n                break;\n\n              case 48:\n                subErrors = errors.concat(pinger.errors);\n                error = new Error(\"No relayer responded or accepted the transaction out of the \".concat(pinger.pingedRelays, \" queried:\\n\").concat(subErrors.map(function (err) {\n                  return \" \".concat(err);\n                }).join('\\n')));\n                error.errors = subErrors;\n                throw error;\n\n              case 52:\n                relayAddress = activeRelay.RelayServerAddress;\n                relayUrl = activeRelay.relayUrl;\n                txfee = parseInt(options.txfee || activeRelay.transactionFee);\n                hash = void 0, signature = void 0;\n                _context4.prev = 56;\n                hash = utils.getTransactionHash(options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, relayHub._address, relayAddress);\n\n                if (!(typeof self.ephemeralKeypair === 'object' && self.ephemeralKeypair !== null)) {\n                  _context4.next = 64;\n                  break;\n                }\n\n                _context4.next = 61;\n                return getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n\n              case 61:\n                signature = _context4.sent;\n                _context4.next = 67;\n                break;\n\n              case 64:\n                _context4.next = 66;\n                return getTransactionSignature(this.web3, options.from, hash);\n\n              case 66:\n                signature = _context4.sent;\n\n              case 67:\n                _context4.next = 72;\n                break;\n\n              case 69:\n                _context4.prev = 69;\n                _context4.t3 = _context4[\"catch\"](56);\n                throw new Error(\"Error generating signature for transaction: \".concat(_context4.t3.message || _context4.t3));\n\n              case 72:\n                _context4.next = 74;\n                return getApprovalData(options.approveFunction, {\n                  from: options.from,\n                  to: options.to,\n                  encodedFunctionCall: encodedFunctionCall,\n                  txFee: txfee,\n                  gasPrice: gasPrice,\n                  gas: gasLimit,\n                  nonce: nonce,\n                  relayHubAddress: relayHub._address,\n                  relayerAddress: relayAddress\n                });\n\n              case 74:\n                approvalData = _context4.sent;\n\n                if (self.config.verbose) {\n                  console.log('relayTransaction hash: ', hash, 'from: ', options.from, 'sig: ', signature);\n                  rec = utils.getEcRecoverMeta(hash, signature);\n\n                  if (rec.toLowerCase() === options.from.toLowerCase()) {\n                    console.log('relayTransaction recovered:', rec, 'signature is correct');\n                  } else {\n                    console.error('relayTransaction recovered:', rec, 'signature error');\n                  }\n                } // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n\n                allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap || this.config.allowedRelayNonceGap;\n\n                if (typeof allowed_relay_nonce_gap === 'undefined') {\n                  allowed_relay_nonce_gap = 3;\n                }\n\n                _context4.next = 80;\n                return this.web3.eth.getTransactionCount(relayAddress);\n\n              case 80:\n                _context4.t4 = _context4.sent;\n                _context4.t5 = allowed_relay_nonce_gap;\n                relayMaxNonce = _context4.t4 + _context4.t5;\n                _context4.prev = 83;\n                _context4.next = 86;\n                return self.sendViaRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData, relayUrl, relayHub._address, relayMaxNonce);\n\n              case 86:\n                validTransaction = _context4.sent;\n                return _context4.abrupt(\"return\", validTransaction);\n\n              case 90:\n                _context4.prev = 90;\n                _context4.t6 = _context4[\"catch\"](83);\n                errMsg = (_context4.t6.message || _context4.t6).toString().replace(/canRelay\\(\\) view function returned error code=(\\d+)\\..+/, function (_match, code) {\n                  return \"canRelay check failed with \".concat(preconditionCodeToDescription(code));\n                });\n                errors.push(\"Error sending transaction via relayer \".concat(relayAddress, \": \").concat(errMsg));\n\n                if (self.config.verbose) {\n                  console.log('relayTransaction: req:', {\n                    from: options.from,\n                    to: options.to,\n                    encodedFunctionCall: encodedFunctionCall,\n                    txfee: txfee,\n                    gasPrice: gasPrice,\n                    gasLimit: gasLimit,\n                    nonce: nonce,\n                    relayhub: relayHub._address,\n                    relayAddress: relayAddress\n                  });\n                  console.log('relayTransaction:', ('' + _context4.t6).replace(/ (\\w+:)/g, '\\n$1 '));\n                }\n\n              case 95:\n                _context4.next = 37;\n                break;\n\n              case 97:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[17, 24], [56, 69], [83, 90]]);\n      }));\n\n      function relayTransaction(_x5, _x6) {\n        return _relayTransaction.apply(this, arguments);\n      }\n\n      return relayTransaction;\n    }()\n  }, {\n    key: \"postAuditTransaction\",\n    value: function postAuditTransaction(signedTx, relayUrl) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(error, response) {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        };\n\n        self.httpSend.send(relayUrl + '/audit', {\n          signedTx: signedTx\n        }, callback);\n      });\n    }\n    /**\n     * Send a transaction signed by a relay to other relays for audit.\n     * This is done in order to prevent nonce reuse by a misbehaving relay.\n     *\n     * @param {*} transaction\n     * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n     */\n\n  }, {\n    key: \"auditTransaction\",\n    value: function () {\n      var _auditTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(transaction, auditingRelays) {\n        var relay;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.t0 = _regeneratorRuntime.keys(auditingRelays);\n\n              case 1:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                relay = _context5.t1.value;\n                _context5.next = 5;\n                return this.postAuditTransaction(transaction, auditingRelays[relay]);\n\n              case 5:\n                _context5.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function auditTransaction(_x7, _x8) {\n        return _auditTransaction.apply(this, arguments);\n      }\n\n      return auditTransaction;\n    }()\n  }, {\n    key: \"useKeypairForSigning\",\n    value: function useKeypairForSigning(ephemeralKeypair) {\n      if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n        ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), 'hex');\n      }\n\n      this.ephemeralKeypair = ephemeralKeypair;\n    }\n  }, {\n    key: \"validateRecipientBalance\",\n    value: function () {\n      var _validateRecipientBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(relayHub, recipient, gasLimit, gasPrice, relayFee) {\n        var balance, maxCharge;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return relayHub.methods.balanceOf(recipient).call();\n\n              case 2:\n                balance = _context6.sent;\n\n                if (!BN(balance).isZero()) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has no funds for paying for relayed calls on the relay hub.\"));\n\n              case 5:\n                _context6.next = 7;\n                return relayHub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n\n              case 7:\n                maxCharge = _context6.sent;\n\n                if (!BN(maxCharge).isGreaterThan(BN(balance))) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has not enough funds for paying for this relayed call (has \").concat(balance, \", requires \").concat(maxCharge, \").\"));\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function validateRecipientBalance(_x9, _x10, _x11, _x12, _x13) {\n        return _validateRecipientBalance.apply(this, arguments);\n      }\n\n      return validateRecipientBalance;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function () {\n      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(txParams, hubAddress) {\n        var hub, txParamsFromHub;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (hubAddress) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                _context7.next = 3;\n                return createRelayHubFromRecipient(this.web3, txParams.to);\n\n              case 3:\n                hub = _context7.sent;\n                hubAddress = hub.options.address;\n\n              case 5:\n                txParamsFromHub = _objectSpread(_objectSpread({}, txParams), {}, {\n                  from: hubAddress,\n                  data: appendAddress(txParams.data, txParams.from)\n                });\n                return _context7.abrupt(\"return\", this.web3.eth.estimateGas(txParamsFromHub));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function estimateGas(_x14, _x15) {\n        return _estimateGas.apply(this, arguments);\n      }\n\n      return estimateGas;\n    }()\n  }], [{\n    key: \"newEphemeralKeypair\",\n    value: function newEphemeralKeypair() {\n      var a = ethWallet.generate();\n      return {\n        privateKey: a.privKey,\n        address: '0x' + a.getAddress().toString('hex')\n      };\n    }\n  }]);\n\n  return RelayClient;\n}();\n\nmodule.exports = RelayClient;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/test1/node_modules/@openzeppelin/gsn-provider/src/tabookey-gasless/RelayClient.js"],"names":["utils","require","getTransactionSignature","getTransactionSignatureWithKey","parseHexString","removeHexPrefix","padTo64","ServerHelper","HttpWrapper","ethUtils","ethWallet","ethJsTx","abi_decoder","BN","appendAddress","toInt","preconditionCodeToDescription","getApprovalData","createRelayHubFromRecipient","relayHubAbi","relayRecipientAbi","relay_lookup_limit_blocks","addABI","DEFAULT_HTTP_TIMEOUT","GASPRICE_PERCENT","RelayClient","web3","config","Object","assign","httpTimeout","httpSend","timeout","failedRelays","serverHelper","payload","relayOptions","getTransactionOptions","relayTransaction","params","data","tx","bufferToHex","hash","relayClientOptions","from","to","txfee","txFee","gas_limit","gas","gas_price","gasPrice","approveFunction","verbose","console","log","id","returned_tx","address_relay","transaction_orig","transaction_fee","nonce","relay_hub_address","relay_address","sig","approvalData","gasLimit","value","input","message","tx_v","Buffer","v","tx_r","r","tx_s","s","signer","pubToAddress","ecrecover","request_decoded_params","decodeMethod","returned_tx_params_hash","getTransactionHash","transaction_orig_params_hash","error","JSON","stringify","relayAddress","encodedFunction","relayFee","gasprice","gaslimit","recipientNonce","signature","relayUrl","relayHubAddress","relayMaxNonce","self","Promise","resolve","reject","jsonRequestData","replace","RecipientNonce","parseInt","RelayMaxNonce","RelayHubAddress","callback","body","indexOf","lastError","Date","getTime","address","url","validTransaction","validateRelayResponse","receivedNonce","readUIntBE","byteLength","raw_tx","serialize","toString","txHash","broadcastRawTx","replacer","key","send","userAgent","tx_hash","eth","sendSignedTransaction","result","match","target","relayHub","methods","balanceOf","call","encodedFunctionCall","options","getNonce","setHub","pct","gasPriceFactorPercent","gaspriceFactorPercent","getGasPrice","network_gas_price","fixedGasPrice","force_gasPrice","Math","round","fixedGasLimit","force_gasLimit","estimateGas","Error","validateRecipientBalance","getBlockNumber","blockNow","blockFrom","max","newActiveRelayPinger","pinger","errors","activeRelay","undefined","preferredRelayer","nextRelay","subErrors","concat","pingedRelays","map","err","join","RelayServerAddress","transactionFee","_address","ephemeralKeypair","privateKey","relayerAddress","rec","getEcRecoverMeta","toLowerCase","allowed_relay_nonce_gap","allowedRelayNonceGap","getTransactionCount","sendViaRelay","errMsg","_match","code","push","relayhub","signedTx","response","transaction","auditingRelays","relay","postAuditTransaction","recipient","balance","isZero","maxPossibleCharge","maxCharge","isGreaterThan","txParams","hubAddress","hub","txParamsFromHub","a","generate","privKey","getAddress","module","exports"],"mappings":"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","sourcesContent":["const utils = require('./utils');\nconst getTransactionSignature = utils.getTransactionSignature;\nconst getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nconst parseHexString = utils.parseHexString;\nconst removeHexPrefix = utils.removeHexPrefix;\nconst padTo64 = utils.padTo64;\n\nconst ServerHelper = require('./ServerHelper');\nconst HttpWrapper = require('./HttpWrapper');\nconst ethUtils = require('ethereumjs-util');\nconst ethWallet = require('ethereumjs-wallet');\nconst ethJsTx = require('ethereumjs-tx');\nconst abi_decoder = require('abi-decoder');\nconst BN = require('bignumber.js');\nconst {\n  appendAddress,\n  toInt,\n  preconditionCodeToDescription,\n  getApprovalData,\n  createRelayHubFromRecipient,\n} = require('../utils');\n\nconst relayHubAbi = require('./IRelayHub');\nconst relayRecipientAbi = require('./IRelayRecipient');\n\nconst relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi);\n\n// default timeout (in ms) for http requests\nconst DEFAULT_HTTP_TIMEOUT = 10000;\n\n//default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\nconst GASPRICE_PERCENT = 20;\n\nclass RelayClient {\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    preferredRelayer - skip relayer lookup and use this preferred relayer, fallbacking to regular lookup on error\n   *       An example preferredRelayer configuration:\n   *        {\n   *          RelayServerAddress: '0x73a652f54d5fd8273f17a28e206d47f5bd1bc06a',\n   *          relayUrl: 'http://localhost:8090',\n   *          transactionFee: '70'\n   *        }\n   *       These values can be be retrieved from the `/getaddr` endpoint of a relayer. e.g `curl http://localhost:8090/getaddr`\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  constructor(web3, config) {\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign(\n      {\n        httpTimeout: DEFAULT_HTTP_TIMEOUT,\n      },\n      config,\n    );\n\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({ timeout: this.config.httpTimeout });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  async sendTransaction(payload) {\n    const relayOptions = this.getTransactionOptions(payload);\n    const tx = await this.relayTransaction(payload.params[0].data, relayOptions);\n    return ethUtils.bufferToHex(tx.hash(true));\n  }\n\n  getTransactionOptions(payload) {\n    const params = payload.params[0];\n    const relayClientOptions = this.config;\n    let relayOptions = {\n      from: params.from,\n      to: params.to,\n      txfee: params.txFee || params.txfee || relayClientOptions.txFee || relayClientOptions.txfee,\n      gas_limit: params.gas && toInt(params.gas),\n      gas_price: params.gasPrice && toInt(params.gasPrice),\n      approveFunction: params.approveFunction || this.config.approveFunction,\n    };\n    if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n    return relayOptions;\n  }\n\n  /**\n   * Decode the signed transaction returned from the Relay Server, compare it to the\n   * requested transaction and validate its signature.\n   * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n   * transaction is not valid.\n   */\n  validateRelayResponse(\n    returned_tx,\n    address_relay,\n    from,\n    to,\n    transaction_orig,\n    transaction_fee,\n    gas_price,\n    gas_limit,\n    nonce,\n    relay_hub_address,\n    relay_address,\n    sig,\n    approvalData,\n  ) {\n    var tx = new ethJsTx({\n      nonce: returned_tx.nonce,\n      gasPrice: returned_tx.gasPrice,\n      gasLimit: returned_tx.gas,\n      to: returned_tx.to,\n      value: returned_tx.value,\n      data: returned_tx.input,\n    });\n\n    let message = tx.hash(false);\n    let tx_v = Buffer.from(removeHexPrefix(returned_tx.v), 'hex');\n    let tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), 'hex');\n    let tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), 'hex');\n\n    let signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n    let request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n    let returned_tx_params_hash = utils.getTransactionHash(\n      request_decoded_params[0].value,\n      request_decoded_params[1].value,\n      request_decoded_params[2].value,\n      request_decoded_params[3].value,\n      request_decoded_params[4].value,\n      request_decoded_params[5].value,\n      request_decoded_params[6].value,\n      returned_tx.to,\n      signer,\n    );\n    let transaction_orig_params_hash = utils.getTransactionHash(\n      from,\n      to,\n      transaction_orig,\n      transaction_fee,\n      gas_price,\n      gas_limit,\n      nonce,\n      relay_hub_address,\n      relay_address,\n    );\n\n    if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n      if (this.config.verbose) {\n        console.log('validateRelayResponse - valid transaction response');\n      }\n      tx.v = tx_v;\n      tx.r = tx_r;\n      tx.s = tx_s;\n      return tx;\n    } else {\n      console.error('validateRelayResponse: req', JSON.stringify(request_decoded_params));\n      console.error('validateRelayResponse: rsp', {\n        returned_tx,\n        address_relay,\n        from,\n        to,\n        transaction_orig,\n        transaction_fee,\n        gas_price,\n        gas_limit,\n        nonce,\n        sig,\n        approvalData,\n        signer,\n      });\n    }\n  }\n\n  /**\n   * Performs a '/relay' HTTP request to the given url\n   * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n   */\n  sendViaRelay(\n    relayAddress,\n    from,\n    to,\n    encodedFunction,\n    relayFee,\n    gasprice,\n    gaslimit,\n    recipientNonce,\n    signature,\n    approvalData,\n    relayUrl,\n    relayHubAddress,\n    relayMaxNonce,\n  ) {\n    var self = this;\n\n    return new Promise(function(resolve, reject) {\n      let jsonRequestData = {\n        encodedFunction: encodedFunction,\n        signature: parseHexString(signature.replace(/^0x/, '')),\n        approvalData: parseHexString(approvalData.replace(/^0x/, '')),\n        from: from,\n        to: to,\n        gasPrice: gasprice,\n        gasLimit: gaslimit,\n        relayFee: relayFee,\n        RecipientNonce: parseInt(recipientNonce),\n        RelayMaxNonce: parseInt(relayMaxNonce),\n        RelayHubAddress: relayHubAddress,\n      };\n\n      let callback = async function(error, body) {\n        if (error) {\n          if (error.error && error.error.indexOf('timeout') != -1) {\n            self.failedRelays[relayUrl] = {\n              lastError: new Date().getTime(),\n              address: relayAddress,\n              url: relayUrl,\n            };\n          }\n          reject(error);\n          return;\n        }\n        if (self.config.verbose) {\n          console.log('sendViaRelay resp=', body);\n        }\n        if (body && body.error) {\n          reject(body.error);\n          return;\n        }\n        if (!body || !body.nonce) {\n          reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n          return;\n        }\n\n        let validTransaction;\n        try {\n          validTransaction = self.validateRelayResponse(\n            body,\n            relayAddress,\n            from,\n            to,\n            encodedFunction,\n            relayFee,\n            gasprice,\n            gaslimit,\n            recipientNonce,\n            relayHubAddress,\n            relayAddress,\n            signature,\n            approvalData,\n          );\n        } catch (error) {\n          console.error('validateRelayResponse ' + error);\n        }\n\n        if (!validTransaction) {\n          reject('Failed to validate response');\n          return;\n        }\n        let receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n        if (receivedNonce > relayMaxNonce) {\n          // TODO: need to validate that client retries the same request and doesn't double-spend.\n          // Note that this transaction is totally valid from the EVM's point of view\n          reject('Relay used a tx nonce higher than requested. Requested ' + relayMaxNonce + ' got ' + receivedNonce);\n          return;\n        }\n\n        var raw_tx = '0x' + validTransaction.serialize().toString('hex');\n        let txHash = '0x' + validTransaction.hash(true).toString('hex');\n        if (self.config.verbose) console.log('txHash= ' + txHash);\n        self.broadcastRawTx(raw_tx, txHash);\n        resolve(validTransaction);\n      };\n\n      if (self.config.verbose) {\n        let replacer = (key, value) => {\n          if (key === 'signature') return signature;\n          else return value;\n        };\n        console.log('sendViaRelay to URL: ' + relayUrl + ' ' + JSON.stringify(jsonRequestData, replacer));\n      }\n      self.httpSend.send(relayUrl + '/relay', { ...jsonRequestData, userAgent: self.config.userAgent }, callback);\n    });\n  }\n\n  /**\n   * In case Relay Server does not broadcast the signed transaction to the network,\n   * client also broadcasts the same transaction. If the transaction fails with nonce\n   * error, it indicates Relay may have signed multiple transactions with same nonce,\n   * causing a DoS attack.\n   *\n   * @param {*} raw_tx - raw transaction bytes, signed by relay\n   * @param {*} tx_hash - this transaction's ID\n   */\n  broadcastRawTx(raw_tx, tx_hash) {\n    var self = this;\n\n    self.web3.eth.sendSignedTransaction(raw_tx, function(error, result) {\n      //TODO: at this point both client and relay has sent the transaction to the blockchain.\n      // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n      // to penalize original relay for cheating: returning one transaction to the client, and\n      // broadcasting another with the same nonce.\n      // see the EIP for description of the attack\n\n      //don't display error for the known-good cases\n      if (!('' + error).match(/the tx doesn't have the correct nonce|known transaction/)) {\n        if (self.config.verbose) {\n          // TODO: Should we actually bubble up an error?\n          console.log('broadcastTx: ', error || result);\n        }\n      }\n\n      if (error) {\n        //note that nonce-related errors at this point are VALID reponses: it means that\n        // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n        // the only point is that different node versions return different error strings:\n        // ganache:  \"the tx doesn't have the correct nonce\"\n        // ropsten: \"known transaction\"\n      } else {\n        if (result == tx_hash) {\n          //transaction already on chain\n        }\n      }\n    });\n  }\n\n  /**\n   * check the balance of the given target contract.\n   * the method will fail if the target is not a RelayRecipient.\n   * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n   */\n  async balanceOf(target) {\n    const relayHub = await createRelayHubFromRecipient(this.web3, target);\n\n    //note that the returned value is a promise too, returning BigNumber\n    return relayHub.methods.balanceOf(target).call();\n  }\n\n  /**\n   * Options include standard transaction params: from,to, gasprice, gaslimit\n   * can also override default relayUrl, relayFee\n   * return value is the same as from sendTransaction\n   */\n  async relayTransaction(encodedFunctionCall, options) {\n    var self = this;\n    const relayHub = await createRelayHubFromRecipient(this.web3, options.to);\n\n    var nonce = parseInt(await relayHub.methods.getNonce(options.from).call());\n\n    this.serverHelper.setHub(relayHub);\n\n    //gas-price multiplicator: either default (10%) or configuration factor\n    let pct = this.config.gasPriceFactorPercent || this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n\n    let network_gas_price = await this.web3.eth.getGasPrice();\n    // Sometimes, xDai netwiork returns '0'\n    if (!network_gas_price || network_gas_price == 0) {\n      network_gas_price = 1e9;\n    }\n\n    let gasPrice =\n      this.config.fixedGasPrice || //forced gasprice\n      this.config.force_gasPrice ||\n      options.gas_price || //user-supplied gas price\n      Math.round((network_gas_price * (pct + 100)) / 100);\n\n    //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n    let gasLimit = this.config.fixedGasLimit || this.config.force_gasLimit || options.gas_limit;\n\n    // If we don't have a gas limit, then estimate it, since we need a concrete value for checking the recipient balance\n    try {\n      if (!gasLimit)\n        gasLimit = await this.estimateGas(\n          {\n            to: options.to,\n            from: options.from,\n            gasPrice,\n            data: encodedFunctionCall,\n          },\n          relayHub.options.address,\n        );\n    } catch (err) {\n      throw new Error(\n        `Error estimating gas usage for transaction (${err.message}). Make sure the transaction is valid, or set a fixed gas value.`,\n      );\n    }\n\n    // Check that the recipient has enough balance in the hub, assuming a relaying fee of zero\n    await this.validateRecipientBalance(relayHub, options.to, gasLimit, gasPrice, 0);\n\n    let blockNow = await this.web3.eth.getBlockNumber();\n    let blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n    let pinger = await this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n    let errors = [];\n\n    let activeRelay;\n    for (;;) {\n      // Relayer lookup - we prefer the preferred relayer, but default to regular lookup on failure\n      if (activeRelay === undefined && self.config.preferredRelayer !== undefined) {\n        activeRelay = self.config.preferredRelayer;\n      } else {\n        const nextRelay = await pinger.nextRelay();\n\n        if (nextRelay) {\n          activeRelay = nextRelay;\n        } else {\n          const subErrors = errors.concat(pinger.errors);\n          const error = new Error(\n            `No relayer responded or accepted the transaction out of the ${\n              pinger.pingedRelays\n            } queried:\\n${subErrors.map(err => ` ${err}`).join('\\n')}`,\n          );\n          error.errors = subErrors;\n          throw error;\n        }\n      }\n\n      let relayAddress = activeRelay.RelayServerAddress;\n      let relayUrl = activeRelay.relayUrl;\n      let txfee = parseInt(options.txfee || activeRelay.transactionFee);\n\n      let hash, signature;\n      try {\n        hash = utils.getTransactionHash(\n          options.from,\n          options.to,\n          encodedFunctionCall,\n          txfee,\n          gasPrice,\n          gasLimit,\n          nonce,\n          relayHub._address,\n          relayAddress,\n        );\n\n        if (typeof self.ephemeralKeypair === 'object' && self.ephemeralKeypair !== null) {\n          signature = await getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n        } else {\n          signature = await getTransactionSignature(this.web3, options.from, hash);\n        }\n      } catch (err) {\n        throw new Error(`Error generating signature for transaction: ${err.message || err}`);\n      }\n\n      const approvalData = await getApprovalData(options.approveFunction, {\n        from: options.from,\n        to: options.to,\n        encodedFunctionCall,\n        txFee: txfee,\n        gasPrice,\n        gas: gasLimit,\n        nonce,\n        relayHubAddress: relayHub._address,\n        relayerAddress: relayAddress,\n      });\n\n      if (self.config.verbose) {\n        console.log('relayTransaction hash: ', hash, 'from: ', options.from, 'sig: ', signature);\n        let rec = utils.getEcRecoverMeta(hash, signature);\n        if (rec.toLowerCase() === options.from.toLowerCase()) {\n          console.log('relayTransaction recovered:', rec, 'signature is correct');\n        } else {\n          console.error('relayTransaction recovered:', rec, 'signature error');\n        }\n      }\n\n      // max nonce is not signed, as contracts cannot access addresses' nonces.\n      let allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap || this.config.allowedRelayNonceGap;\n      if (typeof allowed_relay_nonce_gap === 'undefined') {\n        allowed_relay_nonce_gap = 3;\n      }\n      let relayMaxNonce = (await this.web3.eth.getTransactionCount(relayAddress)) + allowed_relay_nonce_gap;\n\n      try {\n        let validTransaction = await self.sendViaRelay(\n          relayAddress,\n          options.from,\n          options.to,\n          encodedFunctionCall,\n          txfee,\n          gasPrice,\n          gasLimit,\n          nonce,\n          signature,\n          approvalData,\n          relayUrl,\n          relayHub._address,\n          relayMaxNonce,\n        );\n        return validTransaction;\n      } catch (error) {\n        const errMsg = (error.message || error)\n          .toString()\n          .replace(\n            /canRelay\\(\\) view function returned error code=(\\d+)\\..+/,\n            (_match, code) => `canRelay check failed with ${preconditionCodeToDescription(code)}`,\n          );\n        errors.push(`Error sending transaction via relayer ${relayAddress}: ${errMsg}`);\n        if (self.config.verbose) {\n          console.log('relayTransaction: req:', {\n            from: options.from,\n            to: options.to,\n            encodedFunctionCall,\n            txfee,\n            gasPrice,\n            gasLimit,\n            nonce,\n            relayhub: relayHub._address,\n            relayAddress,\n          });\n          console.log('relayTransaction:', ('' + error).replace(/ (\\w+:)/g, '\\n$1 '));\n        }\n      }\n    }\n  }\n\n  postAuditTransaction(signedTx, relayUrl) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n      let callback = function(error, response) {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(response);\n      };\n      self.httpSend.send(relayUrl + '/audit', { signedTx: signedTx }, callback);\n    });\n  }\n\n  /**\n   * Send a transaction signed by a relay to other relays for audit.\n   * This is done in order to prevent nonce reuse by a misbehaving relay.\n   *\n   * @param {*} transaction\n   * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n   */\n  async auditTransaction(transaction, auditingRelays) {\n    for (let relay in auditingRelays) {\n      await this.postAuditTransaction(transaction, auditingRelays[relay]);\n    }\n  }\n\n  static newEphemeralKeypair() {\n    let a = ethWallet.generate();\n    return {\n      privateKey: a.privKey,\n      address: '0x' + a.getAddress().toString('hex'),\n    };\n  }\n\n  useKeypairForSigning(ephemeralKeypair) {\n    if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n      ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), 'hex');\n    }\n    this.ephemeralKeypair = ephemeralKeypair;\n  }\n\n  async validateRecipientBalance(relayHub, recipient, gasLimit, gasPrice, relayFee) {\n    const balance = await relayHub.methods.balanceOf(recipient).call();\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await relayHub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(\n        `Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`,\n      );\n    }\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n    const txParamsFromHub = {\n      ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from),\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n}\n\nmodule.exports = RelayClient;\n"]},"metadata":{},"sourceType":"script"}