{"ast":null,"code":"var _objectSpread = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/john/Documents/GitHub/web3-3/client/web3-7/node_modules/@babel/runtime/helpers/createClass\");\n\nvar HubAbi = require('../tabookey-gasless/IRelayHub');\n\nvar RecipientAbi = require('../tabookey-gasless/IRelayRecipient');\n\nvar BN = require('bignumber.js');\n\nvar _require = require('../utils'),\n    getApprovalData = _require.getApprovalData,\n    appendAddress = _require.appendAddress,\n    preconditionCodeToDescription = _require.preconditionCodeToDescription,\n    createRelayHubFromRecipient = _require.createRelayHubFromRecipient;\n\nvar _require2 = require('../tabookey-gasless/utils'),\n    getTransactionHash = _require2.getTransactionHash,\n    getTransactionSignature = _require2.getTransactionSignature;\n\nvar _require3 = require('../utils'),\n    getCallDataGas = _require3.getCallDataGas;\n\nvar TARGET_BALANCE = 2e18;\nvar MIN_BALANCE = 2e17;\nvar UNSTAKE_DELAY = 3600 * 24 * 7 * 4;\nvar ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar RELAY_STATE = Object.freeze({\n  Unknown: 0,\n  // The relay is unknown to the system: it has never been staked for\n  Staked: 1,\n  // The relay has been staked for, but it is not yet active\n  Registered: 2,\n  // The relay has registered itself, and is active (can relay calls)\n  Removed: 3 // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n\n});\n\nvar DevRelayClient = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function DevRelayClient(web3, ownerAddress, relayerAddress) {\n    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, DevRelayClient);\n\n    this.ownerAddress = ownerAddress;\n    this.relayerAddress = relayerAddress;\n    this.txFee = opts.txFee || 10;\n    this.web3 = web3;\n    this.approveFunction = opts.approveFunction;\n    this.options = opts;\n    this.debug = opts.debug;\n  }\n\n  _createClass(DevRelayClient, [{\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(payload) {\n        var _this = this;\n\n        var txParams, hub, nonce, gasPrice, gas, txHashToSign, signature, approvalData, requiredGas;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.ensureAccounts();\n\n              case 2:\n                // Start by registering in the relayer hub\n                txParams = payload.params[0];\n                _context.next = 5;\n                return createRelayHubFromRecipient(this.web3, txParams.to);\n\n              case 5:\n                hub = _context.sent;\n                _context.next = 8;\n                return this.isRegistered(hub);\n\n              case 8:\n                if (_context.sent) {\n                  _context.next = 12;\n                  break;\n                }\n\n                if (this.debug) console.log(\"Relayer is not registered yet. Registering...\");\n                _context.next = 12;\n                return this.register(hub);\n\n              case 12:\n                _context.t0 = parseInt;\n                _context.next = 15;\n                return hub.methods.getNonce(txParams.from).call();\n\n              case 15:\n                _context.t1 = _context.sent;\n                nonce = (0, _context.t0)(_context.t1);\n                _context.t2 = this.options.fixedGasPrice || txParams.gasPrice;\n\n                if (_context.t2) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _context.next = 21;\n                return this.web3.eth.getGasPrice();\n\n              case 21:\n                _context.t2 = _context.sent;\n\n              case 22:\n                gasPrice = _context.t2;\n                _context.t3 = this.options.fixedGasLimit || txParams.gas;\n\n                if (_context.t3) {\n                  _context.next = 28;\n                  break;\n                }\n\n                _context.next = 27;\n                return this.estimateGas(txParams, hub.options.address);\n\n              case 27:\n                _context.t3 = _context.sent;\n\n              case 28:\n                gas = _context.t3;\n                _context.next = 31;\n                return this.validateRecipientBalance(hub, txParams.to, gas, gasPrice);\n\n              case 31:\n                if (this.debug) console.log(\"Recipient has enough balance to pay for meta tx\");\n                txHashToSign = getTransactionHash(txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, hub.options.address, this.relayerAddress);\n                _context.next = 35;\n                return getTransactionSignature(this.web3, txParams.from, txHashToSign);\n\n              case 35:\n                signature = _context.sent;\n                if (this.debug) console.log(\"Got transaction hash \".concat(txHashToSign, \" with signature \").concat(signature));\n                _context.next = 39;\n                return getApprovalData(txParams.approveFunction || this.approveFunction, {\n                  from: txParams.from,\n                  to: txParams.to,\n                  encodedFunctionCall: txParams.data,\n                  txFee: this.txFee,\n                  gasPrice: gasPrice,\n                  gas: gas,\n                  nonce: nonce,\n                  relayerAddress: this.relayerAddress,\n                  relayHubAddress: hub.options.address\n                });\n\n              case 39:\n                approvalData = _context.sent;\n                if (this.approvalData !== '0x' && this.debug) console.log(\"Approval data is \".concat(approvalData)); // Here the client would send the txParams, signature, and approvalData to the relayer\n                // Instead, we send it from the same process, posing as a relayer\n\n                _context.next = 43;\n                return this.validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData);\n\n              case 43:\n                if (this.debug) console.log(\"Can relay check succeeded\");\n                _context.t4 = BN;\n                _context.next = 47;\n                return hub.methods.requiredGas(gas.toString()).call();\n\n              case 47:\n                _context.t5 = _context.sent;\n                requiredGas = (0, _context.t4)(_context.t5).plus(getCallDataGas(txParams.data)).toString();\n                if (this.debug) console.log(\"Relaying transaction with gas \".concat(requiredGas));\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  hub.methods.relayCall(txParams.from, txParams.to, txParams.data, _this.txFee, gasPrice, gas, nonce, signature, approvalData).send({\n                    from: _this.relayerAddress,\n                    gasPrice: gasPrice,\n                    gas: requiredGas\n                  }).on('transactionHash', function (txHash) {\n                    resolve(txHash);\n                  }).on('error', function (err) {\n                    reject(err);\n                  });\n                }));\n\n              case 51:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendTransaction(_x) {\n        return _sendTransaction.apply(this, arguments);\n      }\n\n      return sendTransaction;\n    }()\n  }, {\n    key: \"validateCanRelay\",\n    value: function () {\n      var _validateCanRelay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(hub, txParams, gasPrice, gas, nonce, signature, approvalData) {\n        var status, recipientContext, _yield$hub$methods$ca;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return hub.methods.canRelay(this.relayerAddress, txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, signature, approvalData).call({\n                  from: this.relayerAddress\n                });\n\n              case 3:\n                _yield$hub$methods$ca = _context2.sent;\n                status = _yield$hub$methods$ca.status;\n                recipientContext = _yield$hub$methods$ca.recipientContext;\n                _context2.next = 11;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw new Error(\"Error checking canRelay for transaction: \".concat(_context2.t0.message || _context2.t0));\n\n              case 11:\n                if (!(parseInt(status) !== 0)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Recipient canRelay call was rejected with \".concat(preconditionCodeToDescription(status)));\n\n              case 13:\n                return _context2.abrupt(\"return\", recipientContext);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 8]]);\n      }));\n\n      function validateCanRelay(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _validateCanRelay.apply(this, arguments);\n      }\n\n      return validateCanRelay;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function () {\n      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(txParams, hubAddress) {\n        var hub, txParamsFromHub;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (hubAddress) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 3;\n                return createRelayHubFromRecipient(this.web3, txParams.to);\n\n              case 3:\n                hub = _context3.sent;\n                hubAddress = hub.options.address;\n\n              case 5:\n                txParamsFromHub = _objectSpread(_objectSpread({}, txParams), {}, {\n                  from: hubAddress,\n                  data: appendAddress(txParams.data, txParams.from)\n                });\n                return _context3.abrupt(\"return\", this.web3.eth.estimateGas(txParamsFromHub));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function estimateGas(_x9, _x10) {\n        return _estimateGas.apply(this, arguments);\n      }\n\n      return estimateGas;\n    }()\n  }, {\n    key: \"validateRecipientBalance\",\n    value: function () {\n      var _validateRecipientBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(hub, recipient, gasLimit, gasPrice) {\n        var relayFee, balance, maxCharge;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                relayFee = this.txFee;\n                _context4.next = 3;\n                return hub.methods.balanceOf(recipient).call();\n\n              case 3:\n                balance = _context4.sent;\n\n                if (!BN(balance).isZero()) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has no funds for paying for relayed calls on the relay hub.\"));\n\n              case 6:\n                _context4.next = 8;\n                return hub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n\n              case 8:\n                maxCharge = _context4.sent;\n\n                if (!BN(maxCharge).isGreaterThan(BN(balance))) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has not enough funds for paying for this relayed call (has \").concat(balance, \", requires \").concat(maxCharge, \").\"));\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function validateRecipientBalance(_x11, _x12, _x13, _x14) {\n        return _validateRecipientBalance.apply(this, arguments);\n      }\n\n      return validateRecipientBalance;\n    }()\n  }, {\n    key: \"register\",\n    value: function () {\n      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(hub) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.ensureAccounts();\n\n              case 2:\n                _context5.next = 4;\n                return this.ensureStake(hub);\n\n              case 4:\n                _context5.next = 6;\n                return hub.methods.registerRelay(this.txFee.toString(), 'http://gsn-dev-relayer.openzeppelin.com/').send({\n                  from: this.relayerAddress\n                });\n\n              case 6:\n                if (this.debug) console.log(\"Registered relayer with address \".concat(this.relayerAddress));\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function register(_x15) {\n        return _register.apply(this, arguments);\n      }\n\n      return register;\n    }()\n  }, {\n    key: \"ensureStake\",\n    value: function () {\n      var _ensureStake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(hub) {\n        var targetBalance,\n            minBalance,\n            currentStake,\n            target,\n            min,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                targetBalance = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : TARGET_BALANCE;\n                minBalance = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : MIN_BALANCE;\n                _context6.next = 4;\n                return this.ensureAccounts();\n\n              case 4:\n                _context6.next = 6;\n                return this.getCurrentStake(hub);\n\n              case 6:\n                currentStake = _context6.sent;\n                target = new BN(targetBalance);\n                min = new BN(minBalance);\n\n                if (!currentStake.gte(min)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                if (this.debug) console.log(\"Current stake \".concat(currentStake.toString(), \" is over minimum stake \").concat(min.toString()));\n                return _context6.abrupt(\"return\");\n\n              case 12:\n                if (this.debug) console.log(\"Staking to reach \".concat(targetBalance.toString()));\n                _context6.next = 15;\n                return hub.methods.stake(this.relayerAddress, UNSTAKE_DELAY.toString()).send({\n                  from: this.ownerAddress,\n                  value: target.minus(currentStake).toString()\n                });\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function ensureStake(_x16) {\n        return _ensureStake.apply(this, arguments);\n      }\n\n      return ensureStake;\n    }()\n  }, {\n    key: \"getCurrentStake\",\n    value: function () {\n      var _getCurrentStake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(hub) {\n        var currentStake;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.ensureAccounts();\n\n              case 2:\n                _context7.prev = 2;\n                _context7.next = 5;\n                return hub.methods.getRelay(this.relayerAddress).call();\n\n              case 5:\n                currentStake = _context7.sent.totalStake;\n                _context7.next = 12;\n                break;\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](2);\n                console.error(\"Error getting current relayer stake \".concat(_context7.t0.message));\n                currentStake = 0;\n\n              case 12:\n                return _context7.abrupt(\"return\", new BN(currentStake));\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[2, 8]]);\n      }));\n\n      function getCurrentStake(_x17) {\n        return _getCurrentStake.apply(this, arguments);\n      }\n\n      return getCurrentStake;\n    }()\n  }, {\n    key: \"isRegistered\",\n    value: function () {\n      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(hub) {\n        var currentState;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return hub.methods.getRelay(this.relayerAddress).call();\n\n              case 3:\n                currentState = _context8.sent.state;\n                _context8.next = 10;\n                break;\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n                console.error(\"Error getting current relayer state \".concat(_context8.t0.message));\n                currentState = 0;\n\n              case 10:\n                return _context8.abrupt(\"return\", Number(currentState) === RELAY_STATE.Registered);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6]]);\n      }));\n\n      function isRegistered(_x18) {\n        return _isRegistered.apply(this, arguments);\n      }\n\n      return isRegistered;\n    }()\n  }, {\n    key: \"ensureAccounts\",\n    value: function () {\n      var _ensureAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var web3, accounts;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(this.ownerAddress && this.relayerAddress)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\");\n\n              case 2:\n                // If the current provider is a PrivateKey one, then eth.getAccounts will return the account\n                // that corresponds to signKey. We need to bypass it to get the actual accounts found on the node.\n                web3 = this.web3.currentProvider.isPrivateKeyProvider ? new this.web3.constructor(this.web3.currentProvider.baseProvider) : this.web3; // Get all accounts and take the first two to use as relayer and owner\n\n                _context9.prev = 3;\n                _context9.next = 6;\n                return web3.eth.getAccounts();\n\n              case 6:\n                accounts = _context9.sent;\n                _context9.next = 12;\n                break;\n\n              case 9:\n                _context9.prev = 9;\n                _context9.t0 = _context9[\"catch\"](3);\n                throw new Error(\"Error getting accounts from local node for GSNDevProvider (\".concat(_context9.t0.message, \"). Please set them manually using the ownerAddress and relayerAddress options.\"));\n\n              case 12:\n                if (!(accounts.length < 2)) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Error setting up owner and relayer accounts for GSNDevProvider (at least two unlocked accounts are needed on the local node but found \".concat(accounts.length, \"). Please set them manually using the ownerAddress and relayerAddress options.\"));\n\n              case 14:\n                this.ownerAddress = this.ownerAddress || accounts[0];\n                this.relayerAddress = this.relayerAddress || accounts[1];\n\n              case 16:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[3, 9]]);\n      }));\n\n      function ensureAccounts() {\n        return _ensureAccounts.apply(this, arguments);\n      }\n\n      return ensureAccounts;\n    }()\n  }]);\n\n  return DevRelayClient;\n}();\n\nmodule.exports = DevRelayClient;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/web3-3/node_modules/@openzeppelin/gsn-provider/src/dev/DevRelayClient.js"],"names":["HubAbi","require","RecipientAbi","BN","getApprovalData","appendAddress","preconditionCodeToDescription","createRelayHubFromRecipient","getTransactionHash","getTransactionSignature","getCallDataGas","TARGET_BALANCE","MIN_BALANCE","UNSTAKE_DELAY","ZERO_ADDRESS","RELAY_STATE","Object","freeze","Unknown","Staked","Registered","Removed","DevRelayClient","web3","ownerAddress","relayerAddress","opts","txFee","approveFunction","options","debug","payload","ensureAccounts","txParams","params","to","hub","isRegistered","console","log","register","parseInt","methods","getNonce","from","call","nonce","fixedGasPrice","gasPrice","eth","getGasPrice","fixedGasLimit","gas","estimateGas","address","validateRecipientBalance","txHashToSign","data","signature","encodedFunctionCall","relayHubAddress","approvalData","validateCanRelay","requiredGas","toString","plus","Promise","resolve","reject","relayCall","send","on","txHash","err","canRelay","status","recipientContext","Error","message","hubAddress","txParamsFromHub","recipient","gasLimit","relayFee","balanceOf","balance","isZero","maxPossibleCharge","maxCharge","isGreaterThan","ensureStake","registerRelay","targetBalance","minBalance","getCurrentStake","currentStake","target","min","gte","stake","value","minus","getRelay","totalStake","error","currentState","state","Number","currentProvider","isPrivateKeyProvider","constructor","baseProvider","getAccounts","accounts","length","module","exports"],"mappings":";;;;;;;;;;AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAC,+BAAD,CAAtB;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,qCAAD,CAA5B;;AACA,IAAME,EAAE,GAAGF,OAAO,CAAC,cAAD,CAAlB;;eAMIA,OAAO,CAAC,UAAD,C;IAJTG,e,YAAAA,e;IACAC,a,YAAAA,a;IACAC,6B,YAAAA,6B;IACAC,2B,YAAAA,2B;;gBAEsDN,OAAO,CAAC,2BAAD,C;IAAvDO,kB,aAAAA,kB;IAAoBC,uB,aAAAA,uB;;gBACDR,OAAO,CAAC,UAAD,C;IAA1BS,c,aAAAA,c;;AAER,IAAMC,cAAc,GAAG,IAAvB;AACA,IAAMC,WAAW,GAAG,IAApB;AACA,IAAMC,aAAa,GAAG,OAAO,EAAP,GAAY,CAAZ,GAAgB,CAAtC;AACA,IAAMC,YAAY,GAAG,4CAArB;AACA,IAAMC,WAAW,GAAGC,MAAM,CAACC,MAAP,CAAc;AAChCC,EAAAA,OAAO,EAAE,CADuB;AACpB;AACZC,EAAAA,MAAM,EAAE,CAFwB;AAErB;AACXC,EAAAA,UAAU,EAAE,CAHoB;AAGjB;AACfC,EAAAA,OAAO,EAAE,CAJuB,CAIlB;;AAJkB,CAAd,CAApB;;IAOMC,c;;;AACJ,0BAAYC,IAAZ,EAAkBC,YAAlB,EAAgCC,cAAhC,EAA2D;AAAA,QAAXC,IAAW,uEAAJ,EAAI;;AAAA;;AACzD,SAAKF,YAAL,GAAoBA,YAApB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKE,KAAL,GAAaD,IAAI,CAACC,KAAL,IAAc,EAA3B;AACA,SAAKJ,IAAL,GAAYA,IAAZ;AACA,SAAKK,eAAL,GAAuBF,IAAI,CAACE,eAA5B;AACA,SAAKC,OAAL,GAAeH,IAAf;AACA,SAAKI,KAAL,GAAaJ,IAAI,CAACI,KAAlB;AACD;;;;;sFAED,iBAAsBC,OAAtB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAEQ,KAAKC,cAAL,EAFR;;AAAA;AAIE;AACMC,gBAAAA,QALR,GAKmBF,OAAO,CAACG,MAAR,CAAe,CAAf,CALnB;AAAA;AAAA,uBAMoB3B,2BAA2B,CAAC,KAAKgB,IAAN,EAAYU,QAAQ,CAACE,EAArB,CAN/C;;AAAA;AAMQC,gBAAAA,GANR;AAAA;AAAA,uBAOa,KAAKC,YAAL,CAAkBD,GAAlB,CAPb;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQI,oBAAI,KAAKN,KAAT,EAAgBQ,OAAO,CAACC,GAAR;AARpB;AAAA,uBASU,KAAKC,QAAL,CAAcJ,GAAd,CATV;;AAAA;AAAA,8BAagBK,QAbhB;AAAA;AAAA,uBAa+BL,GAAG,CAACM,OAAJ,CAAYC,QAAZ,CAAqBV,QAAQ,CAACW,IAA9B,EAAoCC,IAApC,EAb/B;;AAAA;AAAA;AAaQC,gBAAAA,KAbR;AAAA,8BAcmB,KAAKjB,OAAL,CAAakB,aAAb,IAA8Bd,QAAQ,CAACe,QAd1D;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAc6E,KAAKzB,IAAL,CAAU0B,GAAV,CAAcC,WAAd,EAd7E;;AAAA;AAAA;;AAAA;AAcQF,gBAAAA,QAdR;AAAA,8BAec,KAAKnB,OAAL,CAAasB,aAAb,IAA8BlB,QAAQ,CAACmB,GAfrD;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAemE,KAAKC,WAAL,CAAiBpB,QAAjB,EAA2BG,GAAG,CAACP,OAAJ,CAAYyB,OAAvC,CAfnE;;AAAA;AAAA;;AAAA;AAeQF,gBAAAA,GAfR;AAAA;AAAA,uBAiBQ,KAAKG,wBAAL,CAA8BnB,GAA9B,EAAmCH,QAAQ,CAACE,EAA5C,EAAgDiB,GAAhD,EAAqDJ,QAArD,CAjBR;;AAAA;AAkBE,oBAAI,KAAKlB,KAAT,EAAgBQ,OAAO,CAACC,GAAR;AAEViB,gBAAAA,YApBR,GAoBuBhD,kBAAkB,CACrCyB,QAAQ,CAACW,IAD4B,EAErCX,QAAQ,CAACE,EAF4B,EAGrCF,QAAQ,CAACwB,IAH4B,EAIrC,KAAK9B,KAJgC,EAKrCqB,QALqC,EAMrCI,GANqC,EAOrCN,KAPqC,EAQrCV,GAAG,CAACP,OAAJ,CAAYyB,OARyB,EASrC,KAAK7B,cATgC,CApBzC;AAAA;AAAA,uBAgC0BhB,uBAAuB,CAAC,KAAKc,IAAN,EAAYU,QAAQ,CAACW,IAArB,EAA2BY,YAA3B,CAhCjD;;AAAA;AAgCQE,gBAAAA,SAhCR;AAiCE,oBAAI,KAAK5B,KAAT,EAAgBQ,OAAO,CAACC,GAAR,gCAAoCiB,YAApC,6BAAmEE,SAAnE;AAjClB;AAAA,uBAmC6BtD,eAAe,CAAC6B,QAAQ,CAACL,eAAT,IAA4B,KAAKA,eAAlC,EAAmD;AAC3FgB,kBAAAA,IAAI,EAAEX,QAAQ,CAACW,IAD4E;AAE3FT,kBAAAA,EAAE,EAAEF,QAAQ,CAACE,EAF8E;AAG3FwB,kBAAAA,mBAAmB,EAAE1B,QAAQ,CAACwB,IAH6D;AAI3F9B,kBAAAA,KAAK,EAAE,KAAKA,KAJ+E;AAK3FqB,kBAAAA,QAAQ,EAARA,QAL2F;AAM3FI,kBAAAA,GAAG,EAAHA,GAN2F;AAO3FN,kBAAAA,KAAK,EAALA,KAP2F;AAQ3FrB,kBAAAA,cAAc,EAAE,KAAKA,cARsE;AAS3FmC,kBAAAA,eAAe,EAAExB,GAAG,CAACP,OAAJ,CAAYyB;AAT8D,iBAAnD,CAnC5C;;AAAA;AAmCQO,gBAAAA,YAnCR;AA8CE,oBAAI,KAAKA,YAAL,KAAsB,IAAtB,IAA8B,KAAK/B,KAAvC,EAA8CQ,OAAO,CAACC,GAAR,4BAAgCsB,YAAhC,GA9ChD,CAgDE;AACA;;AAjDF;AAAA,uBAkDQ,KAAKC,gBAAL,CAAsB1B,GAAtB,EAA2BH,QAA3B,EAAqCe,QAArC,EAA+CI,GAA/C,EAAoDN,KAApD,EAA2DY,SAA3D,EAAsEG,YAAtE,CAlDR;;AAAA;AAmDE,oBAAI,KAAK/B,KAAT,EAAgBQ,OAAO,CAACC,GAAR;AAnDlB,8BAqDsBpC,EArDtB;AAAA;AAAA,uBAqD+BiC,GAAG,CAACM,OAAJ,CAAYqB,WAAZ,CAAwBX,GAAG,CAACY,QAAJ,EAAxB,EAAwCnB,IAAxC,EArD/B;;AAAA;AAAA;AAqDQkB,gBAAAA,WArDR,iCAsDKE,IAtDL,CAsDUvD,cAAc,CAACuB,QAAQ,CAACwB,IAAV,CAtDxB,EAuDKO,QAvDL;AAwDE,oBAAI,KAAKlC,KAAT,EAAgBQ,OAAO,CAACC,GAAR,yCAA6CwB,WAA7C;AAxDlB,iDA0DS,IAAIG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtChC,kBAAAA,GAAG,CAACM,OAAJ,CACG2B,SADH,CACapC,QAAQ,CAACW,IADtB,EAC4BX,QAAQ,CAACE,EADrC,EACyCF,QAAQ,CAACwB,IADlD,EACwD,KAAI,CAAC9B,KAD7D,EACoEqB,QADpE,EAC8EI,GAD9E,EACmFN,KADnF,EAC0FY,SAD1F,EACqGG,YADrG,EAEGS,IAFH,CAEQ;AAAE1B,oBAAAA,IAAI,EAAE,KAAI,CAACnB,cAAb;AAA6BuB,oBAAAA,QAAQ,EAARA,QAA7B;AAAuCI,oBAAAA,GAAG,EAAEW;AAA5C,mBAFR,EAGGQ,EAHH,CAGM,iBAHN,EAGyB,UAAAC,MAAM,EAAI;AAC/BL,oBAAAA,OAAO,CAACK,MAAD,CAAP;AACD,mBALH,EAMGD,EANH,CAMM,OANN,EAMe,UAAAE,GAAG,EAAI;AAClBL,oBAAAA,MAAM,CAACK,GAAD,CAAN;AACD,mBARH;AASD,iBAVM,CA1DT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;uFAuEA,kBAAuBrC,GAAvB,EAA4BH,QAA5B,EAAsCe,QAAtC,EAAgDI,GAAhD,EAAqDN,KAArD,EAA4DY,SAA5D,EAAuEG,YAAvE;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAG0CzB,GAAG,CAACM,OAAJ,CACnCgC,QADmC,CAElC,KAAKjD,cAF6B,EAGlCQ,QAAQ,CAACW,IAHyB,EAIlCX,QAAQ,CAACE,EAJyB,EAKlCF,QAAQ,CAACwB,IALyB,EAMlC,KAAK9B,KAN6B,EAOlCqB,QAPkC,EAQlCI,GARkC,EASlCN,KATkC,EAUlCY,SAVkC,EAWlCG,YAXkC,EAanChB,IAbmC,CAa9B;AAAED,kBAAAA,IAAI,EAAE,KAAKnB;AAAb,iBAb8B,CAH1C;;AAAA;AAAA;AAGOkD,gBAAAA,MAHP,yBAGOA,MAHP;AAGeC,gBAAAA,gBAHf,yBAGeA,gBAHf;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,sBAkBU,IAAIC,KAAJ,oDAAsD,aAAIC,OAAJ,gBAAtD,EAlBV;;AAAA;AAAA,sBAoBMrC,QAAQ,CAACkC,MAAD,CAAR,KAAqB,CApB3B;AAAA;AAAA;AAAA;;AAAA,sBAqBU,IAAIE,KAAJ,qDAAuDvE,6BAA6B,CAACqE,MAAD,CAApF,EArBV;;AAAA;AAAA,kDAuBSC,gBAvBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;kFA0BA,kBAAkB3C,QAAlB,EAA4B8C,UAA5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACOA,UADP;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAEsBxE,2BAA2B,CAAC,KAAKgB,IAAN,EAAYU,QAAQ,CAACE,EAArB,CAFjD;;AAAA;AAEUC,gBAAAA,GAFV;AAGI2C,gBAAAA,UAAU,GAAG3C,GAAG,CAACP,OAAJ,CAAYyB,OAAzB;;AAHJ;AAKQ0B,gBAAAA,eALR,mCAMO/C,QANP;AAOIW,kBAAAA,IAAI,EAAEmC,UAPV;AAQItB,kBAAAA,IAAI,EAAEpD,aAAa,CAAC4B,QAAQ,CAACwB,IAAV,EAAgBxB,QAAQ,CAACW,IAAzB;AARvB;AAAA,kDAUS,KAAKrB,IAAL,CAAU0B,GAAV,CAAcI,WAAd,CAA0B2B,eAA1B,CAVT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+FAaA,kBAA+B5C,GAA/B,EAAoC6C,SAApC,EAA+CC,QAA/C,EAAyDlC,QAAzD;AAAA;AAAA;AAAA;AAAA;AAAA;AACQmC,gBAAAA,QADR,GACmB,KAAKxD,KADxB;AAAA;AAAA,uBAEwBS,GAAG,CAACM,OAAJ,CAAY0C,SAAZ,CAAsBH,SAAtB,EAAiCpC,IAAjC,EAFxB;;AAAA;AAEQwC,gBAAAA,OAFR;;AAAA,qBAGMlF,EAAE,CAACkF,OAAD,CAAF,CAAYC,MAAZ,EAHN;AAAA;AAAA;AAAA;;AAAA,sBAIU,IAAIT,KAAJ,qBAAuBI,SAAvB,kEAJV;;AAAA;AAAA;AAAA,uBAO0B7C,GAAG,CAACM,OAAJ,CAAY6C,iBAAZ,CAA8BL,QAA9B,EAAwClC,QAAxC,EAAkDmC,QAAlD,EAA4DtC,IAA5D,EAP1B;;AAAA;AAOQ2C,gBAAAA,SAPR;;AAAA,qBAQMrF,EAAE,CAACqF,SAAD,CAAF,CAAcC,aAAd,CAA4BtF,EAAE,CAACkF,OAAD,CAA9B,CARN;AAAA;AAAA;AAAA;;AAAA,sBASU,IAAIR,KAAJ,qBACSI,SADT,yEACiFI,OADjF,wBACsGG,SADtG,QATV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+EAeA,kBAAepD,GAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACQ,KAAKJ,cAAL,EADR;;AAAA;AAAA;AAAA,uBAEQ,KAAK0D,WAAL,CAAiBtD,GAAjB,CAFR;;AAAA;AAAA;AAAA,uBAGQA,GAAG,CAACM,OAAJ,CACHiD,aADG,CACW,KAAKhE,KAAL,CAAWqC,QAAX,EADX,EACkC,0CADlC,EAEHM,IAFG,CAEE;AAAE1B,kBAAAA,IAAI,EAAE,KAAKnB;AAAb,iBAFF,CAHR;;AAAA;AAME,oBAAI,KAAKK,KAAT,EAAgBQ,OAAO,CAACC,GAAR,2CAA+C,KAAKd,cAApD;;AANlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;kFASA,kBAAkBW,GAAlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuBwD,gBAAAA,aAAvB,8DAAuCjF,cAAvC;AAAuDkF,gBAAAA,UAAvD,8DAAoEjF,WAApE;AAAA;AAAA,uBACQ,KAAKoB,cAAL,EADR;;AAAA;AAAA;AAAA,uBAE6B,KAAK8D,eAAL,CAAqB1D,GAArB,CAF7B;;AAAA;AAEQ2D,gBAAAA,YAFR;AAGQC,gBAAAA,MAHR,GAGiB,IAAI7F,EAAJ,CAAOyF,aAAP,CAHjB;AAIQK,gBAAAA,GAJR,GAIc,IAAI9F,EAAJ,CAAO0F,UAAP,CAJd;;AAAA,qBAMME,YAAY,CAACG,GAAb,CAAiBD,GAAjB,CANN;AAAA;AAAA;AAAA;;AAOI,oBAAI,KAAKnE,KAAT,EAAgBQ,OAAO,CAACC,GAAR,yBAA6BwD,YAAY,CAAC/B,QAAb,EAA7B,oCAA8EiC,GAAG,CAACjC,QAAJ,EAA9E;AAPpB;;AAAA;AAWE,oBAAI,KAAKlC,KAAT,EAAgBQ,OAAO,CAACC,GAAR,4BAAgCqD,aAAa,CAAC5B,QAAd,EAAhC;AAXlB;AAAA,uBAYQ5B,GAAG,CAACM,OAAJ,CACHyD,KADG,CACG,KAAK1E,cADR,EACwBZ,aAAa,CAACmD,QAAd,EADxB,EAEHM,IAFG,CAEE;AAAE1B,kBAAAA,IAAI,EAAE,KAAKpB,YAAb;AAA2B4E,kBAAAA,KAAK,EAAEJ,MAAM,CAACK,KAAP,CAAaN,YAAb,EAA2B/B,QAA3B;AAAlC,iBAFF,CAZR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;sFAiBA,kBAAsB5B,GAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACQ,KAAKJ,cAAL,EADR;;AAAA;AAAA;AAAA;AAAA,uBAI0BI,GAAG,CAACM,OAAJ,CAAY4D,QAAZ,CAAqB,KAAK7E,cAA1B,EAA0CoB,IAA1C,EAJ1B;;AAAA;AAIIkD,gBAAAA,YAJJ,kBAI4EQ,UAJ5E;AAAA;AAAA;;AAAA;AAAA;AAAA;AAMIjE,gBAAAA,OAAO,CAACkE,KAAR,+CAAqD,aAAI1B,OAAzD;AACAiB,gBAAAA,YAAY,GAAG,CAAf;;AAPJ;AAAA,kDASS,IAAI5F,EAAJ,CAAO4F,YAAP,CATT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;mFAYA,kBAAmB3D,GAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAG0BA,GAAG,CAACM,OAAJ,CAAY4D,QAAZ,CAAqB,KAAK7E,cAA1B,EAA0CoB,IAA1C,EAH1B;;AAAA;AAGI4D,gBAAAA,YAHJ,kBAG4EC,KAH5E;AAAA;AAAA;;AAAA;AAAA;AAAA;AAKIpE,gBAAAA,OAAO,CAACkE,KAAR,+CAAqD,aAAI1B,OAAzD;AACA2B,gBAAAA,YAAY,GAAG,CAAf;;AANJ;AAAA,kDAQSE,MAAM,CAACF,YAAD,CAAN,KAAyB1F,WAAW,CAACK,UAR9C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;qFAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACM,KAAKI,YAAL,IAAqB,KAAKC,cADhC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAGE;AACA;AACMF,gBAAAA,IALR,GAKe,KAAKA,IAAL,CAAUqF,eAAV,CAA0BC,oBAA1B,GACT,IAAI,KAAKtF,IAAL,CAAUuF,WAAd,CAA0B,KAAKvF,IAAL,CAAUqF,eAAV,CAA0BG,YAApD,CADS,GAET,KAAKxF,IAPX,EASE;;AATF;AAAA;AAAA,uBAYqBA,IAAI,CAAC0B,GAAL,CAAS+D,WAAT,EAZrB;;AAAA;AAYIC,gBAAAA,QAZJ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,sBAcU,IAAIpC,KAAJ,sEAC0D,aAAIC,OAD9D,oFAdV;;AAAA;AAAA,sBAmBMmC,QAAQ,CAACC,MAAT,GAAkB,CAnBxB;AAAA;AAAA;AAAA;;AAAA,sBAoBU,IAAIrC,KAAJ,iJACqIoC,QAAQ,CAACC,MAD9I,oFApBV;;AAAA;AAwBE,qBAAK1F,YAAL,GAAoB,KAAKA,YAAL,IAAqByF,QAAQ,CAAC,CAAD,CAAjD;AACA,qBAAKxF,cAAL,GAAsB,KAAKA,cAAL,IAAuBwF,QAAQ,CAAC,CAAD,CAArD;;AAzBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AA6BFE,MAAM,CAACC,OAAP,GAAiB9F,cAAjB","sourcesContent":["const HubAbi = require('../tabookey-gasless/IRelayHub');\nconst RecipientAbi = require('../tabookey-gasless/IRelayRecipient');\nconst BN = require('bignumber.js');\nconst {\n  getApprovalData,\n  appendAddress,\n  preconditionCodeToDescription,\n  createRelayHubFromRecipient,\n} = require('../utils');\nconst { getTransactionHash, getTransactionSignature } = require('../tabookey-gasless/utils');\nconst { getCallDataGas } = require('../utils');\n\nconst TARGET_BALANCE = 2e18;\nconst MIN_BALANCE = 2e17;\nconst UNSTAKE_DELAY = 3600 * 24 * 7 * 4;\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst RELAY_STATE = Object.freeze({\n  Unknown: 0, // The relay is unknown to the system: it has never been staked for\n  Staked: 1, // The relay has been staked for, but it is not yet active\n  Registered: 2, // The relay has registered itself, and is active (can relay calls)\n  Removed: 3    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n})\n\nclass DevRelayClient {\n  constructor(web3, ownerAddress, relayerAddress, opts = {}) {\n    this.ownerAddress = ownerAddress;\n    this.relayerAddress = relayerAddress;\n    this.txFee = opts.txFee || 10;\n    this.web3 = web3;\n    this.approveFunction = opts.approveFunction;\n    this.options = opts;\n    this.debug = opts.debug;\n  }\n\n  async sendTransaction(payload) {\n    // Set accounts if not set in ctor\n    await this.ensureAccounts();\n\n    // Start by registering in the relayer hub\n    const txParams = payload.params[0];\n    const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n    if(!(await this.isRegistered(hub))) {\n      if (this.debug) console.log(`Relayer is not registered yet. Registering...`);\n      await this.register(hub);\n    }\n\n    // Then sign the transaction as a regular provider would do\n    const nonce = parseInt(await hub.methods.getNonce(txParams.from).call());\n    const gasPrice = this.options.fixedGasPrice || txParams.gasPrice || (await this.web3.eth.getGasPrice());\n    const gas = this.options.fixedGasLimit || txParams.gas || (await this.estimateGas(txParams, hub.options.address));\n\n    await this.validateRecipientBalance(hub, txParams.to, gas, gasPrice);\n    if (this.debug) console.log(`Recipient has enough balance to pay for meta tx`);\n\n    const txHashToSign = getTransactionHash(\n      txParams.from,\n      txParams.to,\n      txParams.data,\n      this.txFee,\n      gasPrice,\n      gas,\n      nonce,\n      hub.options.address,\n      this.relayerAddress,\n    );\n\n    const signature = await getTransactionSignature(this.web3, txParams.from, txHashToSign);\n    if (this.debug) console.log(`Got transaction hash ${txHashToSign} with signature ${signature}`);\n\n    const approvalData = await getApprovalData(txParams.approveFunction || this.approveFunction, {\n      from: txParams.from,\n      to: txParams.to,\n      encodedFunctionCall: txParams.data,\n      txFee: this.txFee,\n      gasPrice,\n      gas,\n      nonce,\n      relayerAddress: this.relayerAddress,\n      relayHubAddress: hub.options.address,\n    });\n    if (this.approvalData !== '0x' && this.debug) console.log(`Approval data is ${approvalData}`);\n\n    // Here the client would send the txParams, signature, and approvalData to the relayer\n    // Instead, we send it from the same process, posing as a relayer\n    await this.validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData);\n    if (this.debug) console.log(`Can relay check succeeded`);\n\n    const requiredGas = BN(await hub.methods.requiredGas(gas.toString()).call())\n      .plus(getCallDataGas(txParams.data))\n      .toString();\n    if (this.debug) console.log(`Relaying transaction with gas ${requiredGas}`);\n\n    return new Promise((resolve, reject) => {\n      hub.methods\n        .relayCall(txParams.from, txParams.to, txParams.data, this.txFee, gasPrice, gas, nonce, signature, approvalData)\n        .send({ from: this.relayerAddress, gasPrice, gas: requiredGas })\n        .on('transactionHash', txHash => {\n          resolve(txHash);\n        })\n        .on('error', err => {\n          reject(err);\n        });\n    });\n  }\n\n  async validateCanRelay(hub, txParams, gasPrice, gas, nonce, signature, approvalData) {\n    let status, recipientContext;\n    try {\n      ({ status, recipientContext } = await hub.methods\n        .canRelay(\n          this.relayerAddress,\n          txParams.from,\n          txParams.to,\n          txParams.data,\n          this.txFee,\n          gasPrice,\n          gas,\n          nonce,\n          signature,\n          approvalData,\n        )\n        .call({ from: this.relayerAddress }));\n    } catch (err) {\n      throw new Error(`Error checking canRelay for transaction: ${err.message || err}`);\n    }\n    if (parseInt(status) !== 0) {\n      throw new Error(`Recipient canRelay call was rejected with ${preconditionCodeToDescription(status)}`);\n    }\n    return recipientContext;\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n    const txParamsFromHub = {\n      ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from),\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n\n  async validateRecipientBalance(hub, recipient, gasLimit, gasPrice) {\n    const relayFee = this.txFee;\n    const balance = await hub.methods.balanceOf(recipient).call();\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await hub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(\n        `Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`,\n      );\n    }\n  }\n\n  async register(hub) {\n    await this.ensureAccounts();\n    await this.ensureStake(hub);\n    await hub.methods\n      .registerRelay(this.txFee.toString(), 'http://gsn-dev-relayer.openzeppelin.com/')\n      .send({ from: this.relayerAddress });\n    if (this.debug) console.log(`Registered relayer with address ${this.relayerAddress}`);\n  }\n\n  async ensureStake(hub, targetBalance = TARGET_BALANCE, minBalance = MIN_BALANCE) {\n    await this.ensureAccounts();\n    const currentStake = await this.getCurrentStake(hub);\n    const target = new BN(targetBalance);\n    const min = new BN(minBalance);\n\n    if (currentStake.gte(min)) {\n      if (this.debug) console.log(`Current stake ${currentStake.toString()} is over minimum stake ${min.toString()}`);\n      return;\n    }\n\n    if (this.debug) console.log(`Staking to reach ${targetBalance.toString()}`);\n    await hub.methods\n      .stake(this.relayerAddress, UNSTAKE_DELAY.toString())\n      .send({ from: this.ownerAddress, value: target.minus(currentStake).toString() });\n  }\n\n  async getCurrentStake(hub) {\n    await this.ensureAccounts();\n    let currentStake;\n    try {\n      currentStake = (await hub.methods.getRelay(this.relayerAddress).call()).totalStake;\n    } catch (err) {\n      console.error(`Error getting current relayer stake ${err.message}`)\n      currentStake = 0;\n    }\n    return new BN(currentStake);\n  }\n\n  async isRegistered(hub) {\n    let currentState;\n    try {\n      currentState = (await hub.methods.getRelay(this.relayerAddress).call()).state;\n    } catch (err) {\n      console.error(`Error getting current relayer state ${err.message}`)\n      currentState = 0;\n    }\n    return Number(currentState) === RELAY_STATE.Registered;\n  }\n\n  async ensureAccounts() {\n    if (this.ownerAddress && this.relayerAddress) return;\n\n    // If the current provider is a PrivateKey one, then eth.getAccounts will return the account\n    // that corresponds to signKey. We need to bypass it to get the actual accounts found on the node.\n    const web3 = this.web3.currentProvider.isPrivateKeyProvider\n      ? new this.web3.constructor(this.web3.currentProvider.baseProvider)\n      : this.web3;\n\n    // Get all accounts and take the first two to use as relayer and owner\n    let accounts;\n    try {\n      accounts = await web3.eth.getAccounts();\n    } catch (err) {\n      throw new Error(\n        `Error getting accounts from local node for GSNDevProvider (${err.message}). Please set them manually using the ownerAddress and relayerAddress options.`,\n      );\n    }\n\n    if (accounts.length < 2) {\n      throw new Error(\n        `Error setting up owner and relayer accounts for GSNDevProvider (at least two unlocked accounts are needed on the local node but found ${accounts.length}). Please set them manually using the ownerAddress and relayerAddress options.`,\n      );\n    }\n    this.ownerAddress = this.ownerAddress || accounts[0];\n    this.relayerAddress = this.relayerAddress || accounts[1];\n  }\n}\n\nmodule.exports = DevRelayClient;\n"]},"metadata":{},"sourceType":"script"}