{"ast":null,"code":"const utils = require('./utils');\n\nconst getTransactionSignature = utils.getTransactionSignature;\nconst getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nconst parseHexString = utils.parseHexString;\nconst removeHexPrefix = utils.removeHexPrefix;\nconst padTo64 = utils.padTo64;\n\nconst ServerHelper = require('./ServerHelper');\n\nconst HttpWrapper = require('./HttpWrapper');\n\nconst ethUtils = require('ethereumjs-util');\n\nconst ethWallet = require('ethereumjs-wallet');\n\nconst ethJsTx = require('ethereumjs-tx');\n\nconst abi_decoder = require('abi-decoder');\n\nconst BN = require('bignumber.js');\n\nconst {\n  appendAddress,\n  toInt,\n  preconditionCodeToDescription,\n  getApprovalData,\n  createRelayHubFromRecipient\n} = require('../utils');\n\nconst relayHubAbi = require('./IRelayHub');\n\nconst relayRecipientAbi = require('./IRelayRecipient');\n\nconst relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi); // default timeout (in ms) for http requests\n\nconst DEFAULT_HTTP_TIMEOUT = 10000; //default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\n\nconst GASPRICE_PERCENT = 20;\n\nclass RelayClient {\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    preferredRelayer - skip relayer lookup and use this preferred relayer, fallbacking to regular lookup on error\n   *       An example preferredRelayer configuration:\n   *        {\n   *          RelayServerAddress: '0x73a652f54d5fd8273f17a28e206d47f5bd1bc06a',\n   *          relayUrl: 'http://localhost:8090',\n   *          transactionFee: '70'\n   *        }\n   *       These values can be be retrieved from the `/getaddr` endpoint of a relayer. e.g `curl http://localhost:8090/getaddr`\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  constructor(web3, config) {\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign({\n      httpTimeout: DEFAULT_HTTP_TIMEOUT\n    }, config);\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({\n      timeout: this.config.httpTimeout\n    });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  async sendTransaction(payload) {\n    const relayOptions = this.getTransactionOptions(payload);\n    const tx = await this.relayTransaction(payload.params[0].data, relayOptions);\n    return ethUtils.bufferToHex(tx.hash(true));\n  }\n\n  getTransactionOptions(payload) {\n    const params = payload.params[0];\n    const relayClientOptions = this.config;\n    let relayOptions = {\n      from: params.from,\n      to: params.to,\n      txfee: params.txFee || params.txfee || relayClientOptions.txFee || relayClientOptions.txfee,\n      gas_limit: params.gas && toInt(params.gas),\n      gas_price: params.gasPrice && toInt(params.gasPrice),\n      approveFunction: params.approveFunction || this.config.approveFunction\n    };\n    if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n    return relayOptions;\n  }\n  /**\n   * Decode the signed transaction returned from the Relay Server, compare it to the\n   * requested transaction and validate its signature.\n   * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n   * transaction is not valid.\n   */\n\n\n  validateRelayResponse(returned_tx, address_relay, from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address, sig, approvalData) {\n    var tx = new ethJsTx({\n      nonce: returned_tx.nonce,\n      gasPrice: returned_tx.gasPrice,\n      gasLimit: returned_tx.gas,\n      to: returned_tx.to,\n      value: returned_tx.value,\n      data: returned_tx.input\n    });\n    let message = tx.hash(false);\n    let tx_v = Buffer.from(removeHexPrefix(returned_tx.v), 'hex');\n    let tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), 'hex');\n    let tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), 'hex');\n    let signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n    let request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n    let returned_tx_params_hash = utils.getTransactionHash(request_decoded_params[0].value, request_decoded_params[1].value, request_decoded_params[2].value, request_decoded_params[3].value, request_decoded_params[4].value, request_decoded_params[5].value, request_decoded_params[6].value, returned_tx.to, signer);\n    let transaction_orig_params_hash = utils.getTransactionHash(from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address);\n\n    if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n      if (this.config.verbose) {\n        console.log('validateRelayResponse - valid transaction response');\n      }\n\n      tx.v = tx_v;\n      tx.r = tx_r;\n      tx.s = tx_s;\n      return tx;\n    } else {\n      console.error('validateRelayResponse: req', JSON.stringify(request_decoded_params));\n      console.error('validateRelayResponse: rsp', {\n        returned_tx,\n        address_relay,\n        from,\n        to,\n        transaction_orig,\n        transaction_fee,\n        gas_price,\n        gas_limit,\n        nonce,\n        sig,\n        approvalData,\n        signer\n      });\n    }\n  }\n  /**\n   * Performs a '/relay' HTTP request to the given url\n   * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n   */\n\n\n  sendViaRelay(relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, signature, approvalData, relayUrl, relayHubAddress, relayMaxNonce) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      let jsonRequestData = {\n        encodedFunction: encodedFunction,\n        signature: parseHexString(signature.replace(/^0x/, '')),\n        approvalData: parseHexString(approvalData.replace(/^0x/, '')),\n        from: from,\n        to: to,\n        gasPrice: gasprice,\n        gasLimit: gaslimit,\n        relayFee: relayFee,\n        RecipientNonce: parseInt(recipientNonce),\n        RelayMaxNonce: parseInt(relayMaxNonce),\n        RelayHubAddress: relayHubAddress\n      };\n\n      let callback = async function (error, body) {\n        if (error) {\n          if (error.error && error.error.indexOf('timeout') != -1) {\n            self.failedRelays[relayUrl] = {\n              lastError: new Date().getTime(),\n              address: relayAddress,\n              url: relayUrl\n            };\n          }\n\n          reject(error);\n          return;\n        }\n\n        if (self.config.verbose) {\n          console.log('sendViaRelay resp=', body);\n        }\n\n        if (body && body.error) {\n          reject(body.error);\n          return;\n        }\n\n        if (!body || !body.nonce) {\n          reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n          return;\n        }\n\n        let validTransaction;\n\n        try {\n          validTransaction = self.validateRelayResponse(body, relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, relayHubAddress, relayAddress, signature, approvalData);\n        } catch (error) {\n          console.error('validateRelayResponse ' + error);\n        }\n\n        if (!validTransaction) {\n          reject('Failed to validate response');\n          return;\n        }\n\n        let receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n\n        if (receivedNonce > relayMaxNonce) {\n          // TODO: need to validate that client retries the same request and doesn't double-spend.\n          // Note that this transaction is totally valid from the EVM's point of view\n          reject('Relay used a tx nonce higher than requested. Requested ' + relayMaxNonce + ' got ' + receivedNonce);\n          return;\n        }\n\n        var raw_tx = '0x' + validTransaction.serialize().toString('hex');\n        let txHash = '0x' + validTransaction.hash(true).toString('hex');\n        if (self.config.verbose) console.log('txHash= ' + txHash);\n        self.broadcastRawTx(raw_tx, txHash);\n        resolve(validTransaction);\n      };\n\n      if (self.config.verbose) {\n        let replacer = (key, value) => {\n          if (key === 'signature') return signature;else return value;\n        };\n\n        console.log('sendViaRelay to URL: ' + relayUrl + ' ' + JSON.stringify(jsonRequestData, replacer));\n      }\n\n      self.httpSend.send(relayUrl + '/relay', { ...jsonRequestData,\n        userAgent: self.config.userAgent\n      }, callback);\n    });\n  }\n  /**\n   * In case Relay Server does not broadcast the signed transaction to the network,\n   * client also broadcasts the same transaction. If the transaction fails with nonce\n   * error, it indicates Relay may have signed multiple transactions with same nonce,\n   * causing a DoS attack.\n   *\n   * @param {*} raw_tx - raw transaction bytes, signed by relay\n   * @param {*} tx_hash - this transaction's ID\n   */\n\n\n  broadcastRawTx(raw_tx, tx_hash) {\n    var self = this;\n    self.web3.eth.sendSignedTransaction(raw_tx, function (error, result) {\n      //TODO: at this point both client and relay has sent the transaction to the blockchain.\n      // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n      // to penalize original relay for cheating: returning one transaction to the client, and\n      // broadcasting another with the same nonce.\n      // see the EIP for description of the attack\n      //don't display error for the known-good cases\n      if (!('' + error).match(/the tx doesn't have the correct nonce|known transaction/)) {\n        if (self.config.verbose) {\n          // TODO: Should we actually bubble up an error?\n          console.log('broadcastTx: ', error || result);\n        }\n      }\n\n      if (error) {//note that nonce-related errors at this point are VALID reponses: it means that\n        // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n        // the only point is that different node versions return different error strings:\n        // ganache:  \"the tx doesn't have the correct nonce\"\n        // ropsten: \"known transaction\"\n      } else {\n        if (result == tx_hash) {//transaction already on chain\n        }\n      }\n    });\n  }\n  /**\n   * check the balance of the given target contract.\n   * the method will fail if the target is not a RelayRecipient.\n   * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n   */\n\n\n  async balanceOf(target) {\n    const relayHub = await createRelayHubFromRecipient(this.web3, target); //note that the returned value is a promise too, returning BigNumber\n\n    return relayHub.methods.balanceOf(target).call();\n  }\n  /**\n   * Options include standard transaction params: from,to, gasprice, gaslimit\n   * can also override default relayUrl, relayFee\n   * return value is the same as from sendTransaction\n   */\n\n\n  async relayTransaction(encodedFunctionCall, options) {\n    var self = this;\n    const relayHub = await createRelayHubFromRecipient(this.web3, options.to);\n    var nonce = parseInt(await relayHub.methods.getNonce(options.from).call());\n    this.serverHelper.setHub(relayHub); //gas-price multiplicator: either default (10%) or configuration factor\n\n    let pct = this.config.gasPriceFactorPercent || this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n    let network_gas_price = await this.web3.eth.getGasPrice(); // Sometimes, xDai netwiork returns '0'\n\n    if (!network_gas_price || network_gas_price == 0) {\n      network_gas_price = 1e9;\n    }\n\n    let gasPrice = this.config.fixedGasPrice || //forced gasprice\n    this.config.force_gasPrice || options.gas_price || //user-supplied gas price\n    Math.round(network_gas_price * (pct + 100) / 100); //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n\n    let gasLimit = this.config.fixedGasLimit || this.config.force_gasLimit || options.gas_limit; // If we don't have a gas limit, then estimate it, since we need a concrete value for checking the recipient balance\n\n    try {\n      if (!gasLimit) gasLimit = await this.estimateGas({\n        to: options.to,\n        from: options.from,\n        gasPrice,\n        data: encodedFunctionCall\n      }, relayHub.options.address);\n    } catch (err) {\n      throw new Error(`Error estimating gas usage for transaction (${err.message}). Make sure the transaction is valid, or set a fixed gas value.`);\n    } // Check that the recipient has enough balance in the hub, assuming a relaying fee of zero\n\n\n    await this.validateRecipientBalance(relayHub, options.to, gasLimit, gasPrice, 0);\n    let blockNow = await this.web3.eth.getBlockNumber();\n    let blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n    let pinger = await this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n    let errors = [];\n    let activeRelay;\n\n    for (;;) {\n      // Relayer lookup - we prefer the preferred relayer, but default to regular lookup on failure\n      if (activeRelay === undefined && self.config.preferredRelayer !== undefined) {\n        activeRelay = self.config.preferredRelayer;\n      } else {\n        const nextRelay = await pinger.nextRelay();\n\n        if (nextRelay) {\n          activeRelay = nextRelay;\n        } else {\n          const subErrors = errors.concat(pinger.errors);\n          const error = new Error(`No relayer responded or accepted the transaction out of the ${pinger.pingedRelays} queried:\\n${subErrors.map(err => ` ${err}`).join('\\n')}`);\n          error.errors = subErrors;\n          throw error;\n        }\n      }\n\n      let relayAddress = activeRelay.RelayServerAddress;\n      let relayUrl = activeRelay.relayUrl;\n      let txfee = parseInt(options.txfee || activeRelay.transactionFee);\n      let hash, signature;\n\n      try {\n        hash = utils.getTransactionHash(options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, relayHub._address, relayAddress);\n\n        if (typeof self.ephemeralKeypair === 'object' && self.ephemeralKeypair !== null) {\n          signature = await getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n        } else {\n          signature = await getTransactionSignature(this.web3, options.from, hash);\n        }\n      } catch (err) {\n        throw new Error(`Error generating signature for transaction: ${err.message || err}`);\n      }\n\n      const approvalData = await getApprovalData(options.approveFunction, {\n        from: options.from,\n        to: options.to,\n        encodedFunctionCall,\n        txFee: txfee,\n        gasPrice,\n        gas: gasLimit,\n        nonce,\n        relayHubAddress: relayHub._address,\n        relayerAddress: relayAddress\n      });\n\n      if (self.config.verbose) {\n        console.log('relayTransaction hash: ', hash, 'from: ', options.from, 'sig: ', signature);\n        let rec = utils.getEcRecoverMeta(hash, signature);\n\n        if (rec.toLowerCase() === options.from.toLowerCase()) {\n          console.log('relayTransaction recovered:', rec, 'signature is correct');\n        } else {\n          console.error('relayTransaction recovered:', rec, 'signature error');\n        }\n      } // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n\n      let allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap || this.config.allowedRelayNonceGap;\n\n      if (typeof allowed_relay_nonce_gap === 'undefined') {\n        allowed_relay_nonce_gap = 3;\n      }\n\n      let relayMaxNonce = (await this.web3.eth.getTransactionCount(relayAddress)) + allowed_relay_nonce_gap;\n\n      try {\n        let validTransaction = await self.sendViaRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData, relayUrl, relayHub._address, relayMaxNonce);\n        return validTransaction;\n      } catch (error) {\n        const errMsg = (error.message || error).toString().replace(/canRelay\\(\\) view function returned error code=(\\d+)\\..+/, (_match, code) => `canRelay check failed with ${preconditionCodeToDescription(code)}`);\n        errors.push(`Error sending transaction via relayer ${relayAddress}: ${errMsg}`);\n\n        if (self.config.verbose) {\n          console.log('relayTransaction: req:', {\n            from: options.from,\n            to: options.to,\n            encodedFunctionCall,\n            txfee,\n            gasPrice,\n            gasLimit,\n            nonce,\n            relayhub: relayHub._address,\n            relayAddress\n          });\n          console.log('relayTransaction:', ('' + error).replace(/ (\\w+:)/g, '\\n$1 '));\n        }\n      }\n    }\n  }\n\n  postAuditTransaction(signedTx, relayUrl) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      let callback = function (error, response) {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response);\n      };\n\n      self.httpSend.send(relayUrl + '/audit', {\n        signedTx: signedTx\n      }, callback);\n    });\n  }\n  /**\n   * Send a transaction signed by a relay to other relays for audit.\n   * This is done in order to prevent nonce reuse by a misbehaving relay.\n   *\n   * @param {*} transaction\n   * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n   */\n\n\n  async auditTransaction(transaction, auditingRelays) {\n    for (let relay in auditingRelays) {\n      await this.postAuditTransaction(transaction, auditingRelays[relay]);\n    }\n  }\n\n  static newEphemeralKeypair() {\n    let a = ethWallet.generate();\n    return {\n      privateKey: a.privKey,\n      address: '0x' + a.getAddress().toString('hex')\n    };\n  }\n\n  useKeypairForSigning(ephemeralKeypair) {\n    if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n      ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), 'hex');\n    }\n\n    this.ephemeralKeypair = ephemeralKeypair;\n  }\n\n  async validateRecipientBalance(relayHub, recipient, gasLimit, gasPrice, relayFee) {\n    const balance = await relayHub.methods.balanceOf(recipient).call();\n\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await relayHub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(`Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`);\n    }\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n\n    const txParamsFromHub = { ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from)\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n\n}\n\nmodule.exports = RelayClient;","map":{"version":3,"sources":["/Users/john/Documents/GitHub/web3-3/node_modules/@openzeppelin/gsn-provider/src/tabookey-gasless/RelayClient.js"],"names":["utils","require","getTransactionSignature","getTransactionSignatureWithKey","parseHexString","removeHexPrefix","padTo64","ServerHelper","HttpWrapper","ethUtils","ethWallet","ethJsTx","abi_decoder","BN","appendAddress","toInt","preconditionCodeToDescription","getApprovalData","createRelayHubFromRecipient","relayHubAbi","relayRecipientAbi","relay_lookup_limit_blocks","addABI","DEFAULT_HTTP_TIMEOUT","GASPRICE_PERCENT","RelayClient","constructor","web3","config","Object","assign","httpTimeout","httpSend","timeout","failedRelays","serverHelper","sendTransaction","payload","relayOptions","getTransactionOptions","tx","relayTransaction","params","data","bufferToHex","hash","relayClientOptions","from","to","txfee","txFee","gas_limit","gas","gas_price","gasPrice","approveFunction","verbose","console","log","id","validateRelayResponse","returned_tx","address_relay","transaction_orig","transaction_fee","nonce","relay_hub_address","relay_address","sig","approvalData","gasLimit","value","input","message","tx_v","Buffer","v","tx_r","r","tx_s","s","signer","pubToAddress","ecrecover","request_decoded_params","decodeMethod","returned_tx_params_hash","getTransactionHash","transaction_orig_params_hash","error","JSON","stringify","sendViaRelay","relayAddress","encodedFunction","relayFee","gasprice","gaslimit","recipientNonce","signature","relayUrl","relayHubAddress","relayMaxNonce","self","Promise","resolve","reject","jsonRequestData","replace","RecipientNonce","parseInt","RelayMaxNonce","RelayHubAddress","callback","body","indexOf","lastError","Date","getTime","address","url","validTransaction","receivedNonce","readUIntBE","byteLength","raw_tx","serialize","toString","txHash","broadcastRawTx","replacer","key","send","userAgent","tx_hash","eth","sendSignedTransaction","result","match","balanceOf","target","relayHub","methods","call","encodedFunctionCall","options","getNonce","setHub","pct","gasPriceFactorPercent","gaspriceFactorPercent","network_gas_price","getGasPrice","fixedGasPrice","force_gasPrice","Math","round","fixedGasLimit","force_gasLimit","estimateGas","err","Error","validateRecipientBalance","blockNow","getBlockNumber","blockFrom","max","pinger","newActiveRelayPinger","errors","activeRelay","undefined","preferredRelayer","nextRelay","subErrors","concat","pingedRelays","map","join","RelayServerAddress","transactionFee","_address","ephemeralKeypair","privateKey","relayerAddress","rec","getEcRecoverMeta","toLowerCase","allowed_relay_nonce_gap","allowedRelayNonceGap","getTransactionCount","errMsg","_match","code","push","relayhub","postAuditTransaction","signedTx","response","auditTransaction","transaction","auditingRelays","relay","newEphemeralKeypair","a","generate","privKey","getAddress","useKeypairForSigning","recipient","balance","isZero","maxCharge","maxPossibleCharge","isGreaterThan","txParams","hubAddress","hub","txParamsFromHub","module","exports"],"mappings":"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","sourcesContent":["const utils = require('./utils');\nconst getTransactionSignature = utils.getTransactionSignature;\nconst getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nconst parseHexString = utils.parseHexString;\nconst removeHexPrefix = utils.removeHexPrefix;\nconst padTo64 = utils.padTo64;\n\nconst ServerHelper = require('./ServerHelper');\nconst HttpWrapper = require('./HttpWrapper');\nconst ethUtils = require('ethereumjs-util');\nconst ethWallet = require('ethereumjs-wallet');\nconst ethJsTx = require('ethereumjs-tx');\nconst abi_decoder = require('abi-decoder');\nconst BN = require('bignumber.js');\nconst {\n  appendAddress,\n  toInt,\n  preconditionCodeToDescription,\n  getApprovalData,\n  createRelayHubFromRecipient,\n} = require('../utils');\n\nconst relayHubAbi = require('./IRelayHub');\nconst relayRecipientAbi = require('./IRelayRecipient');\n\nconst relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi);\n\n// default timeout (in ms) for http requests\nconst DEFAULT_HTTP_TIMEOUT = 10000;\n\n//default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\nconst GASPRICE_PERCENT = 20;\n\nclass RelayClient {\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    preferredRelayer - skip relayer lookup and use this preferred relayer, fallbacking to regular lookup on error\n   *       An example preferredRelayer configuration:\n   *        {\n   *          RelayServerAddress: '0x73a652f54d5fd8273f17a28e206d47f5bd1bc06a',\n   *          relayUrl: 'http://localhost:8090',\n   *          transactionFee: '70'\n   *        }\n   *       These values can be be retrieved from the `/getaddr` endpoint of a relayer. e.g `curl http://localhost:8090/getaddr`\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  constructor(web3, config) {\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign(\n      {\n        httpTimeout: DEFAULT_HTTP_TIMEOUT,\n      },\n      config,\n    );\n\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({ timeout: this.config.httpTimeout });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  async sendTransaction(payload) {\n    const relayOptions = this.getTransactionOptions(payload);\n    const tx = await this.relayTransaction(payload.params[0].data, relayOptions);\n    return ethUtils.bufferToHex(tx.hash(true));\n  }\n\n  getTransactionOptions(payload) {\n    const params = payload.params[0];\n    const relayClientOptions = this.config;\n    let relayOptions = {\n      from: params.from,\n      to: params.to,\n      txfee: params.txFee || params.txfee || relayClientOptions.txFee || relayClientOptions.txfee,\n      gas_limit: params.gas && toInt(params.gas),\n      gas_price: params.gasPrice && toInt(params.gasPrice),\n      approveFunction: params.approveFunction || this.config.approveFunction,\n    };\n    if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n    return relayOptions;\n  }\n\n  /**\n   * Decode the signed transaction returned from the Relay Server, compare it to the\n   * requested transaction and validate its signature.\n   * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n   * transaction is not valid.\n   */\n  validateRelayResponse(\n    returned_tx,\n    address_relay,\n    from,\n    to,\n    transaction_orig,\n    transaction_fee,\n    gas_price,\n    gas_limit,\n    nonce,\n    relay_hub_address,\n    relay_address,\n    sig,\n    approvalData,\n  ) {\n    var tx = new ethJsTx({\n      nonce: returned_tx.nonce,\n      gasPrice: returned_tx.gasPrice,\n      gasLimit: returned_tx.gas,\n      to: returned_tx.to,\n      value: returned_tx.value,\n      data: returned_tx.input,\n    });\n\n    let message = tx.hash(false);\n    let tx_v = Buffer.from(removeHexPrefix(returned_tx.v), 'hex');\n    let tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), 'hex');\n    let tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), 'hex');\n\n    let signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n    let request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n    let returned_tx_params_hash = utils.getTransactionHash(\n      request_decoded_params[0].value,\n      request_decoded_params[1].value,\n      request_decoded_params[2].value,\n      request_decoded_params[3].value,\n      request_decoded_params[4].value,\n      request_decoded_params[5].value,\n      request_decoded_params[6].value,\n      returned_tx.to,\n      signer,\n    );\n    let transaction_orig_params_hash = utils.getTransactionHash(\n      from,\n      to,\n      transaction_orig,\n      transaction_fee,\n      gas_price,\n      gas_limit,\n      nonce,\n      relay_hub_address,\n      relay_address,\n    );\n\n    if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n      if (this.config.verbose) {\n        console.log('validateRelayResponse - valid transaction response');\n      }\n      tx.v = tx_v;\n      tx.r = tx_r;\n      tx.s = tx_s;\n      return tx;\n    } else {\n      console.error('validateRelayResponse: req', JSON.stringify(request_decoded_params));\n      console.error('validateRelayResponse: rsp', {\n        returned_tx,\n        address_relay,\n        from,\n        to,\n        transaction_orig,\n        transaction_fee,\n        gas_price,\n        gas_limit,\n        nonce,\n        sig,\n        approvalData,\n        signer,\n      });\n    }\n  }\n\n  /**\n   * Performs a '/relay' HTTP request to the given url\n   * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n   */\n  sendViaRelay(\n    relayAddress,\n    from,\n    to,\n    encodedFunction,\n    relayFee,\n    gasprice,\n    gaslimit,\n    recipientNonce,\n    signature,\n    approvalData,\n    relayUrl,\n    relayHubAddress,\n    relayMaxNonce,\n  ) {\n    var self = this;\n\n    return new Promise(function(resolve, reject) {\n      let jsonRequestData = {\n        encodedFunction: encodedFunction,\n        signature: parseHexString(signature.replace(/^0x/, '')),\n        approvalData: parseHexString(approvalData.replace(/^0x/, '')),\n        from: from,\n        to: to,\n        gasPrice: gasprice,\n        gasLimit: gaslimit,\n        relayFee: relayFee,\n        RecipientNonce: parseInt(recipientNonce),\n        RelayMaxNonce: parseInt(relayMaxNonce),\n        RelayHubAddress: relayHubAddress,\n      };\n\n      let callback = async function(error, body) {\n        if (error) {\n          if (error.error && error.error.indexOf('timeout') != -1) {\n            self.failedRelays[relayUrl] = {\n              lastError: new Date().getTime(),\n              address: relayAddress,\n              url: relayUrl,\n            };\n          }\n          reject(error);\n          return;\n        }\n        if (self.config.verbose) {\n          console.log('sendViaRelay resp=', body);\n        }\n        if (body && body.error) {\n          reject(body.error);\n          return;\n        }\n        if (!body || !body.nonce) {\n          reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n          return;\n        }\n\n        let validTransaction;\n        try {\n          validTransaction = self.validateRelayResponse(\n            body,\n            relayAddress,\n            from,\n            to,\n            encodedFunction,\n            relayFee,\n            gasprice,\n            gaslimit,\n            recipientNonce,\n            relayHubAddress,\n            relayAddress,\n            signature,\n            approvalData,\n          );\n        } catch (error) {\n          console.error('validateRelayResponse ' + error);\n        }\n\n        if (!validTransaction) {\n          reject('Failed to validate response');\n          return;\n        }\n        let receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n        if (receivedNonce > relayMaxNonce) {\n          // TODO: need to validate that client retries the same request and doesn't double-spend.\n          // Note that this transaction is totally valid from the EVM's point of view\n          reject('Relay used a tx nonce higher than requested. Requested ' + relayMaxNonce + ' got ' + receivedNonce);\n          return;\n        }\n\n        var raw_tx = '0x' + validTransaction.serialize().toString('hex');\n        let txHash = '0x' + validTransaction.hash(true).toString('hex');\n        if (self.config.verbose) console.log('txHash= ' + txHash);\n        self.broadcastRawTx(raw_tx, txHash);\n        resolve(validTransaction);\n      };\n\n      if (self.config.verbose) {\n        let replacer = (key, value) => {\n          if (key === 'signature') return signature;\n          else return value;\n        };\n        console.log('sendViaRelay to URL: ' + relayUrl + ' ' + JSON.stringify(jsonRequestData, replacer));\n      }\n      self.httpSend.send(relayUrl + '/relay', { ...jsonRequestData, userAgent: self.config.userAgent }, callback);\n    });\n  }\n\n  /**\n   * In case Relay Server does not broadcast the signed transaction to the network,\n   * client also broadcasts the same transaction. If the transaction fails with nonce\n   * error, it indicates Relay may have signed multiple transactions with same nonce,\n   * causing a DoS attack.\n   *\n   * @param {*} raw_tx - raw transaction bytes, signed by relay\n   * @param {*} tx_hash - this transaction's ID\n   */\n  broadcastRawTx(raw_tx, tx_hash) {\n    var self = this;\n\n    self.web3.eth.sendSignedTransaction(raw_tx, function(error, result) {\n      //TODO: at this point both client and relay has sent the transaction to the blockchain.\n      // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n      // to penalize original relay for cheating: returning one transaction to the client, and\n      // broadcasting another with the same nonce.\n      // see the EIP for description of the attack\n\n      //don't display error for the known-good cases\n      if (!('' + error).match(/the tx doesn't have the correct nonce|known transaction/)) {\n        if (self.config.verbose) {\n          // TODO: Should we actually bubble up an error?\n          console.log('broadcastTx: ', error || result);\n        }\n      }\n\n      if (error) {\n        //note that nonce-related errors at this point are VALID reponses: it means that\n        // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n        // the only point is that different node versions return different error strings:\n        // ganache:  \"the tx doesn't have the correct nonce\"\n        // ropsten: \"known transaction\"\n      } else {\n        if (result == tx_hash) {\n          //transaction already on chain\n        }\n      }\n    });\n  }\n\n  /**\n   * check the balance of the given target contract.\n   * the method will fail if the target is not a RelayRecipient.\n   * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n   */\n  async balanceOf(target) {\n    const relayHub = await createRelayHubFromRecipient(this.web3, target);\n\n    //note that the returned value is a promise too, returning BigNumber\n    return relayHub.methods.balanceOf(target).call();\n  }\n\n  /**\n   * Options include standard transaction params: from,to, gasprice, gaslimit\n   * can also override default relayUrl, relayFee\n   * return value is the same as from sendTransaction\n   */\n  async relayTransaction(encodedFunctionCall, options) {\n    var self = this;\n    const relayHub = await createRelayHubFromRecipient(this.web3, options.to);\n\n    var nonce = parseInt(await relayHub.methods.getNonce(options.from).call());\n\n    this.serverHelper.setHub(relayHub);\n\n    //gas-price multiplicator: either default (10%) or configuration factor\n    let pct = this.config.gasPriceFactorPercent || this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n\n    let network_gas_price = await this.web3.eth.getGasPrice();\n    // Sometimes, xDai netwiork returns '0'\n    if (!network_gas_price || network_gas_price == 0) {\n      network_gas_price = 1e9;\n    }\n\n    let gasPrice =\n      this.config.fixedGasPrice || //forced gasprice\n      this.config.force_gasPrice ||\n      options.gas_price || //user-supplied gas price\n      Math.round((network_gas_price * (pct + 100)) / 100);\n\n    //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n    let gasLimit = this.config.fixedGasLimit || this.config.force_gasLimit || options.gas_limit;\n\n    // If we don't have a gas limit, then estimate it, since we need a concrete value for checking the recipient balance\n    try {\n      if (!gasLimit)\n        gasLimit = await this.estimateGas(\n          {\n            to: options.to,\n            from: options.from,\n            gasPrice,\n            data: encodedFunctionCall,\n          },\n          relayHub.options.address,\n        );\n    } catch (err) {\n      throw new Error(\n        `Error estimating gas usage for transaction (${err.message}). Make sure the transaction is valid, or set a fixed gas value.`,\n      );\n    }\n\n    // Check that the recipient has enough balance in the hub, assuming a relaying fee of zero\n    await this.validateRecipientBalance(relayHub, options.to, gasLimit, gasPrice, 0);\n\n    let blockNow = await this.web3.eth.getBlockNumber();\n    let blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n    let pinger = await this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n    let errors = [];\n\n    let activeRelay;\n    for (;;) {\n      // Relayer lookup - we prefer the preferred relayer, but default to regular lookup on failure\n      if (activeRelay === undefined && self.config.preferredRelayer !== undefined) {\n        activeRelay = self.config.preferredRelayer;\n      } else {\n        const nextRelay = await pinger.nextRelay();\n\n        if (nextRelay) {\n          activeRelay = nextRelay;\n        } else {\n          const subErrors = errors.concat(pinger.errors);\n          const error = new Error(\n            `No relayer responded or accepted the transaction out of the ${\n              pinger.pingedRelays\n            } queried:\\n${subErrors.map(err => ` ${err}`).join('\\n')}`,\n          );\n          error.errors = subErrors;\n          throw error;\n        }\n      }\n\n      let relayAddress = activeRelay.RelayServerAddress;\n      let relayUrl = activeRelay.relayUrl;\n      let txfee = parseInt(options.txfee || activeRelay.transactionFee);\n\n      let hash, signature;\n      try {\n        hash = utils.getTransactionHash(\n          options.from,\n          options.to,\n          encodedFunctionCall,\n          txfee,\n          gasPrice,\n          gasLimit,\n          nonce,\n          relayHub._address,\n          relayAddress,\n        );\n\n        if (typeof self.ephemeralKeypair === 'object' && self.ephemeralKeypair !== null) {\n          signature = await getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n        } else {\n          signature = await getTransactionSignature(this.web3, options.from, hash);\n        }\n      } catch (err) {\n        throw new Error(`Error generating signature for transaction: ${err.message || err}`);\n      }\n\n      const approvalData = await getApprovalData(options.approveFunction, {\n        from: options.from,\n        to: options.to,\n        encodedFunctionCall,\n        txFee: txfee,\n        gasPrice,\n        gas: gasLimit,\n        nonce,\n        relayHubAddress: relayHub._address,\n        relayerAddress: relayAddress,\n      });\n\n      if (self.config.verbose) {\n        console.log('relayTransaction hash: ', hash, 'from: ', options.from, 'sig: ', signature);\n        let rec = utils.getEcRecoverMeta(hash, signature);\n        if (rec.toLowerCase() === options.from.toLowerCase()) {\n          console.log('relayTransaction recovered:', rec, 'signature is correct');\n        } else {\n          console.error('relayTransaction recovered:', rec, 'signature error');\n        }\n      }\n\n      // max nonce is not signed, as contracts cannot access addresses' nonces.\n      let allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap || this.config.allowedRelayNonceGap;\n      if (typeof allowed_relay_nonce_gap === 'undefined') {\n        allowed_relay_nonce_gap = 3;\n      }\n      let relayMaxNonce = (await this.web3.eth.getTransactionCount(relayAddress)) + allowed_relay_nonce_gap;\n\n      try {\n        let validTransaction = await self.sendViaRelay(\n          relayAddress,\n          options.from,\n          options.to,\n          encodedFunctionCall,\n          txfee,\n          gasPrice,\n          gasLimit,\n          nonce,\n          signature,\n          approvalData,\n          relayUrl,\n          relayHub._address,\n          relayMaxNonce,\n        );\n        return validTransaction;\n      } catch (error) {\n        const errMsg = (error.message || error)\n          .toString()\n          .replace(\n            /canRelay\\(\\) view function returned error code=(\\d+)\\..+/,\n            (_match, code) => `canRelay check failed with ${preconditionCodeToDescription(code)}`,\n          );\n        errors.push(`Error sending transaction via relayer ${relayAddress}: ${errMsg}`);\n        if (self.config.verbose) {\n          console.log('relayTransaction: req:', {\n            from: options.from,\n            to: options.to,\n            encodedFunctionCall,\n            txfee,\n            gasPrice,\n            gasLimit,\n            nonce,\n            relayhub: relayHub._address,\n            relayAddress,\n          });\n          console.log('relayTransaction:', ('' + error).replace(/ (\\w+:)/g, '\\n$1 '));\n        }\n      }\n    }\n  }\n\n  postAuditTransaction(signedTx, relayUrl) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n      let callback = function(error, response) {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(response);\n      };\n      self.httpSend.send(relayUrl + '/audit', { signedTx: signedTx }, callback);\n    });\n  }\n\n  /**\n   * Send a transaction signed by a relay to other relays for audit.\n   * This is done in order to prevent nonce reuse by a misbehaving relay.\n   *\n   * @param {*} transaction\n   * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n   */\n  async auditTransaction(transaction, auditingRelays) {\n    for (let relay in auditingRelays) {\n      await this.postAuditTransaction(transaction, auditingRelays[relay]);\n    }\n  }\n\n  static newEphemeralKeypair() {\n    let a = ethWallet.generate();\n    return {\n      privateKey: a.privKey,\n      address: '0x' + a.getAddress().toString('hex'),\n    };\n  }\n\n  useKeypairForSigning(ephemeralKeypair) {\n    if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n      ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), 'hex');\n    }\n    this.ephemeralKeypair = ephemeralKeypair;\n  }\n\n  async validateRecipientBalance(relayHub, recipient, gasLimit, gasPrice, relayFee) {\n    const balance = await relayHub.methods.balanceOf(recipient).call();\n    if (BN(balance).isZero()) {\n      throw new Error(`Recipient ${recipient} has no funds for paying for relayed calls on the relay hub.`);\n    }\n\n    const maxCharge = await relayHub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n    if (BN(maxCharge).isGreaterThan(BN(balance))) {\n      throw new Error(\n        `Recipient ${recipient} has not enough funds for paying for this relayed call (has ${balance}, requires ${maxCharge}).`,\n      );\n    }\n  }\n\n  async estimateGas(txParams, hubAddress) {\n    if (!hubAddress) {\n      const hub = await createRelayHubFromRecipient(this.web3, txParams.to);\n      hubAddress = hub.options.address;\n    }\n    const txParamsFromHub = {\n      ...txParams,\n      from: hubAddress,\n      data: appendAddress(txParams.data, txParams.from),\n    };\n    return this.web3.eth.estimateGas(txParamsFromHub);\n  }\n}\n\nmodule.exports = RelayClient;\n"]},"metadata":{},"sourceType":"script"}